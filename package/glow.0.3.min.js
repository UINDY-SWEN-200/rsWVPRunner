/*! Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.4
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( event.wheelDelta ) { delta = event.wheelDelta/120; }
    if ( event.detail     ) { delta = -event.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return $.event.handle.apply(this, args);
}

})(jQuery);
/* Javascript plotting library for jQuery, v. 0.7.
 *
 * Released under the MIT license by IOLA, December 2007.
 *
 */
(function(b){b.color={};b.color.make=function(d,e,g,f){var c={};c.r=d||0;c.g=e||0;c.b=g||0;c.a=f!=null?f:1;c.add=function(h,j){for(var k=0;k<h.length;++k){c[h.charAt(k)]+=j}return c.normalize()};c.scale=function(h,j){for(var k=0;k<h.length;++k){c[h.charAt(k)]*=j}return c.normalize()};c.toString=function(){if(c.a>=1){return"rgb("+[c.r,c.g,c.b].join(",")+")"}else{return"rgba("+[c.r,c.g,c.b,c.a].join(",")+")"}};c.normalize=function(){function h(k,j,l){return j<k?k:(j>l?l:j)}c.r=h(0,parseInt(c.r),255);c.g=h(0,parseInt(c.g),255);c.b=h(0,parseInt(c.b),255);c.a=h(0,c.a,1);return c};c.clone=function(){return b.color.make(c.r,c.b,c.g,c.a)};return c.normalize()};b.color.extract=function(d,e){var c;do{c=d.css(e).toLowerCase();if(c!=""&&c!="transparent"){break}d=d.parent()}while(!b.nodeName(d.get(0),"body"));if(c=="rgba(0, 0, 0, 0)"){c="transparent"}return b.color.parse(c)};b.color.parse=function(c){var d,f=b.color.make;if(d=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c)){return f(parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10))}if(d=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(c)){return f(parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10),parseFloat(d[4]))}if(d=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c)){return f(parseFloat(d[1])*2.55,parseFloat(d[2])*2.55,parseFloat(d[3])*2.55)}if(d=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(c)){return f(parseFloat(d[1])*2.55,parseFloat(d[2])*2.55,parseFloat(d[3])*2.55,parseFloat(d[4]))}if(d=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c)){return f(parseInt(d[1],16),parseInt(d[2],16),parseInt(d[3],16))}if(d=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c)){return f(parseInt(d[1]+d[1],16),parseInt(d[2]+d[2],16),parseInt(d[3]+d[3],16))}var e=b.trim(c).toLowerCase();if(e=="transparent"){return f(255,255,255,0)}else{d=a[e]||[0,0,0];return f(d[0],d[1],d[2])}};var a={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);(function(c){function b(av,ai,J,af){var Q=[],O={colors:["#edc240","#afd8f8","#cb4b4b","#4da74d","#9440ed"],legend:{show:true,noColumns:1,labelFormatter:null,labelBoxBorderColor:"#ccc",container:null,position:"ne",margin:5,backgroundColor:null,backgroundOpacity:0.85},xaxis:{show:null,position:"bottom",mode:null,color:null,tickColor:null,transform:null,inverseTransform:null,min:null,max:null,autoscaleMargin:null,ticks:null,tickFormatter:null,labelWidth:null,labelHeight:null,reserveSpace:null,tickLength:null,alignTicksWithAxis:null,tickDecimals:null,tickSize:null,minTickSize:null,monthNames:null,timeformat:null,twelveHourClock:false},yaxis:{autoscaleMargin:0.02,position:"left"},xaxes:[],yaxes:[],series:{points:{show:false,radius:3,lineWidth:2,fill:true,fillColor:"#ffffff",symbol:"circle"},lines:{lineWidth:2,fill:false,fillColor:null,steps:false},bars:{show:false,lineWidth:2,barWidth:1,fill:true,fillColor:null,align:"left",horizontal:false},shadowSize:3},grid:{show:true,aboveData:false,color:"#545454",backgroundColor:null,borderColor:null,tickColor:null,labelMargin:5,axisMargin:8,borderWidth:2,minBorderMargin:null,markings:null,markingsColor:"#f4f4f4",markingsLineWidth:2,clickable:false,hoverable:false,autoHighlight:true,mouseActiveRadius:10},hooks:{}},az=null,ad=null,y=null,H=null,A=null,p=[],aw=[],q={left:0,right:0,top:0,bottom:0},G=0,I=0,h=0,w=0,ak={processOptions:[],processRawData:[],processDatapoints:[],drawSeries:[],draw:[],bindEvents:[],drawOverlay:[],shutdown:[]},aq=this;aq.setData=aj;aq.setupGrid=t;aq.draw=W;aq.getPlaceholder=function(){return av};aq.getCanvas=function(){return az};aq.getPlotOffset=function(){return q};aq.width=function(){return h};aq.height=function(){return w};aq.offset=function(){var aB=y.offset();aB.left+=q.left;aB.top+=q.top;return aB};aq.getData=function(){return Q};aq.getAxes=function(){var aC={},aB;c.each(p.concat(aw),function(aD,aE){if(aE){aC[aE.direction+(aE.n!=1?aE.n:"")+"axis"]=aE}});return aC};aq.getXAxes=function(){return p};aq.getYAxes=function(){return aw};aq.c2p=C;aq.p2c=ar;aq.getOptions=function(){return O};aq.highlight=x;aq.unhighlight=T;aq.triggerRedrawOverlay=f;aq.pointOffset=function(aB){return{left:parseInt(p[aA(aB,"x")-1].p2c(+aB.x)+q.left),top:parseInt(aw[aA(aB,"y")-1].p2c(+aB.y)+q.top)}};aq.shutdown=ag;aq.resize=function(){B();g(az);g(ad)};aq.hooks=ak;F(aq);Z(J);X();aj(ai);t();W();ah();function an(aD,aB){aB=[aq].concat(aB);for(var aC=0;aC<aD.length;++aC){aD[aC].apply(this,aB)}}function F(){for(var aB=0;aB<af.length;++aB){var aC=af[aB];aC.init(aq);if(aC.options){c.extend(true,O,aC.options)}}}function Z(aC){var aB;c.extend(true,O,aC);if(O.xaxis.color==null){O.xaxis.color=O.grid.color}if(O.yaxis.color==null){O.yaxis.color=O.grid.color}if(O.xaxis.tickColor==null){O.xaxis.tickColor=O.grid.tickColor}if(O.yaxis.tickColor==null){O.yaxis.tickColor=O.grid.tickColor}if(O.grid.borderColor==null){O.grid.borderColor=O.grid.color}if(O.grid.tickColor==null){O.grid.tickColor=c.color.parse(O.grid.color).scale("a",0.22).toString()}for(aB=0;aB<Math.max(1,O.xaxes.length);++aB){O.xaxes[aB]=c.extend(true,{},O.xaxis,O.xaxes[aB])}for(aB=0;aB<Math.max(1,O.yaxes.length);++aB){O.yaxes[aB]=c.extend(true,{},O.yaxis,O.yaxes[aB])}if(O.xaxis.noTicks&&O.xaxis.ticks==null){O.xaxis.ticks=O.xaxis.noTicks}if(O.yaxis.noTicks&&O.yaxis.ticks==null){O.yaxis.ticks=O.yaxis.noTicks}if(O.x2axis){O.xaxes[1]=c.extend(true,{},O.xaxis,O.x2axis);O.xaxes[1].position="top"}if(O.y2axis){O.yaxes[1]=c.extend(true,{},O.yaxis,O.y2axis);O.yaxes[1].position="right"}if(O.grid.coloredAreas){O.grid.markings=O.grid.coloredAreas}if(O.grid.coloredAreasColor){O.grid.markingsColor=O.grid.coloredAreasColor}if(O.lines){c.extend(true,O.series.lines,O.lines)}if(O.points){c.extend(true,O.series.points,O.points)}if(O.bars){c.extend(true,O.series.bars,O.bars)}if(O.shadowSize!=null){O.series.shadowSize=O.shadowSize}for(aB=0;aB<O.xaxes.length;++aB){V(p,aB+1).options=O.xaxes[aB]}for(aB=0;aB<O.yaxes.length;++aB){V(aw,aB+1).options=O.yaxes[aB]}for(var aD in ak){if(O.hooks[aD]&&O.hooks[aD].length){ak[aD]=ak[aD].concat(O.hooks[aD])}}an(ak.processOptions,[O])}function aj(aB){Q=Y(aB);ax();z()}function Y(aE){var aC=[];for(var aB=0;aB<aE.length;++aB){var aD=c.extend(true,{},O.series);if(aE[aB].data!=null){aD.data=aE[aB].data;delete aE[aB].data;c.extend(true,aD,aE[aB]);aE[aB].data=aD.data}else{aD.data=aE[aB]}aC.push(aD)}return aC}function aA(aC,aD){var aB=aC[aD+"axis"];if(typeof aB=="object"){aB=aB.n}if(typeof aB!="number"){aB=1}return aB}function m(){return c.grep(p.concat(aw),function(aB){return aB})}function C(aE){var aC={},aB,aD;for(aB=0;aB<p.length;++aB){aD=p[aB];if(aD&&aD.used){aC["x"+aD.n]=aD.c2p(aE.left)}}for(aB=0;aB<aw.length;++aB){aD=aw[aB];if(aD&&aD.used){aC["y"+aD.n]=aD.c2p(aE.top)}}if(aC.x1!==undefined){aC.x=aC.x1}if(aC.y1!==undefined){aC.y=aC.y1}return aC}function ar(aF){var aD={},aC,aE,aB;for(aC=0;aC<p.length;++aC){aE=p[aC];if(aE&&aE.used){aB="x"+aE.n;if(aF[aB]==null&&aE.n==1){aB="x"}if(aF[aB]!=null){aD.left=aE.p2c(aF[aB]);break}}}for(aC=0;aC<aw.length;++aC){aE=aw[aC];if(aE&&aE.used){aB="y"+aE.n;if(aF[aB]==null&&aE.n==1){aB="y"}if(aF[aB]!=null){aD.top=aE.p2c(aF[aB]);break}}}return aD}function V(aC,aB){if(!aC[aB-1]){aC[aB-1]={n:aB,direction:aC==p?"x":"y",options:c.extend(true,{},aC==p?O.xaxis:O.yaxis)}}return aC[aB-1]}function ax(){var aG;var aM=Q.length,aB=[],aE=[];for(aG=0;aG<Q.length;++aG){var aJ=Q[aG].color;if(aJ!=null){--aM;if(typeof aJ=="number"){aE.push(aJ)}else{aB.push(c.color.parse(Q[aG].color))}}}for(aG=0;aG<aE.length;++aG){aM=Math.max(aM,aE[aG]+1)}var aC=[],aF=0;aG=0;while(aC.length<aM){var aI;if(O.colors.length==aG){aI=c.color.make(100,100,100)}else{aI=c.color.parse(O.colors[aG])}var aD=aF%2==1?-1:1;aI.scale("rgb",1+aD*Math.ceil(aF/2)*0.2);aC.push(aI);++aG;if(aG>=O.colors.length){aG=0;++aF}}var aH=0,aN;for(aG=0;aG<Q.length;++aG){aN=Q[aG];if(aN.color==null){aN.color=aC[aH].toString();++aH}else{if(typeof aN.color=="number"){aN.color=aC[aN.color].toString()}}if(aN.lines.show==null){var aL,aK=true;for(aL in aN){if(aN[aL]&&aN[aL].show){aK=false;break}}if(aK){aN.lines.show=true}}aN.xaxis=V(p,aA(aN,"x"));aN.yaxis=V(aw,aA(aN,"y"))}}function z(){var aO=Number.POSITIVE_INFINITY,aI=Number.NEGATIVE_INFINITY,aB=Number.MAX_VALUE,aU,aS,aR,aN,aD,aJ,aT,aP,aH,aG,aC,a0,aX,aL;function aF(a3,a2,a1){if(a2<a3.datamin&&a2!=-aB){a3.datamin=a2}if(a1>a3.datamax&&a1!=aB){a3.datamax=a1}}c.each(m(),function(a1,a2){a2.datamin=aO;a2.datamax=aI;a2.used=false});for(aU=0;aU<Q.length;++aU){aJ=Q[aU];aJ.datapoints={points:[]};an(ak.processRawData,[aJ,aJ.data,aJ.datapoints])}for(aU=0;aU<Q.length;++aU){aJ=Q[aU];var aZ=aJ.data,aW=aJ.datapoints.format;if(!aW){aW=[];aW.push({x:true,number:true,required:true});aW.push({y:true,number:true,required:true});if(aJ.bars.show||(aJ.lines.show&&aJ.lines.fill)){aW.push({y:true,number:true,required:false,defaultValue:0});if(aJ.bars.horizontal){delete aW[aW.length-1].y;aW[aW.length-1].x=true}}aJ.datapoints.format=aW}if(aJ.datapoints.pointsize!=null){continue}aJ.datapoints.pointsize=aW.length;aP=aJ.datapoints.pointsize;aT=aJ.datapoints.points;insertSteps=aJ.lines.show&&aJ.lines.steps;aJ.xaxis.used=aJ.yaxis.used=true;for(aS=aR=0;aS<aZ.length;++aS,aR+=aP){aL=aZ[aS];var aE=aL==null;if(!aE){for(aN=0;aN<aP;++aN){a0=aL[aN];aX=aW[aN];if(aX){if(aX.number&&a0!=null){a0=+a0;if(isNaN(a0)){a0=null}else{if(a0==Infinity){a0=aB}else{if(a0==-Infinity){a0=-aB}}}}if(a0==null){if(aX.required){aE=true}if(aX.defaultValue!=null){a0=aX.defaultValue}}}aT[aR+aN]=a0}}if(aE){for(aN=0;aN<aP;++aN){a0=aT[aR+aN];if(a0!=null){aX=aW[aN];if(aX.x){aF(aJ.xaxis,a0,a0)}if(aX.y){aF(aJ.yaxis,a0,a0)}}aT[aR+aN]=null}}else{if(insertSteps&&aR>0&&aT[aR-aP]!=null&&aT[aR-aP]!=aT[aR]&&aT[aR-aP+1]!=aT[aR+1]){for(aN=0;aN<aP;++aN){aT[aR+aP+aN]=aT[aR+aN]}aT[aR+1]=aT[aR-aP+1];aR+=aP}}}}for(aU=0;aU<Q.length;++aU){aJ=Q[aU];an(ak.processDatapoints,[aJ,aJ.datapoints])}for(aU=0;aU<Q.length;++aU){aJ=Q[aU];aT=aJ.datapoints.points,aP=aJ.datapoints.pointsize;var aK=aO,aQ=aO,aM=aI,aV=aI;for(aS=0;aS<aT.length;aS+=aP){if(aT[aS]==null){continue}for(aN=0;aN<aP;++aN){a0=aT[aS+aN];aX=aW[aN];if(!aX||a0==aB||a0==-aB){continue}if(aX.x){if(a0<aK){aK=a0}if(a0>aM){aM=a0}}if(aX.y){if(a0<aQ){aQ=a0}if(a0>aV){aV=a0}}}}if(aJ.bars.show){var aY=aJ.bars.align=="left"?0:-aJ.bars.barWidth/2;if(aJ.bars.horizontal){aQ+=aY;aV+=aY+aJ.bars.barWidth}else{aK+=aY;aM+=aY+aJ.bars.barWidth}}aF(aJ.xaxis,aK,aM);aF(aJ.yaxis,aQ,aV)}c.each(m(),function(a1,a2){if(a2.datamin==aO){a2.datamin=null}if(a2.datamax==aI){a2.datamax=null}})}function j(aB,aC){var aD=document.createElement("canvas");aD.className=aC;aD.width=G;aD.height=I;if(!aB){c(aD).css({position:"absolute",left:0,top:0})}c(aD).appendTo(av);if(!aD.getContext){aD=window.G_vmlCanvasManager.initElement(aD)}aD.getContext("2d").save();return aD}function B(){G=av.width();I=av.height();if(G<=0||I<=0){throw"Invalid dimensions for plot, width = "+G+", height = "+I}}function g(aC){if(aC.width!=G){aC.width=G}if(aC.height!=I){aC.height=I}var aB=aC.getContext("2d");aB.restore();aB.save()}function X(){var aC,aB=av.children("canvas.base"),aD=av.children("canvas.overlay");if(aB.length==0||aD==0){av.html("");av.css({padding:0});if(av.css("position")=="static"){av.css("position","relative")}B();az=j(true,"base");ad=j(false,"overlay");aC=false}else{az=aB.get(0);ad=aD.get(0);aC=true}H=az.getContext("2d");A=ad.getContext("2d");y=c([ad,az]);if(aC){av.data("plot").shutdown();aq.resize();A.clearRect(0,0,G,I);y.unbind();av.children().not([az,ad]).remove()}av.data("plot",aq)}function ah(){if(O.grid.hoverable){y.mousemove(aa);y.mouseleave(l)}if(O.grid.clickable){y.click(R)}an(ak.bindEvents,[y])}function ag(){if(M){clearTimeout(M)}y.unbind("mousemove",aa);y.unbind("mouseleave",l);y.unbind("click",R);an(ak.shutdown,[y])}function r(aG){function aC(aH){return aH}var aF,aB,aD=aG.options.transform||aC,aE=aG.options.inverseTransform;if(aG.direction=="x"){aF=aG.scale=h/Math.abs(aD(aG.max)-aD(aG.min));aB=Math.min(aD(aG.max),aD(aG.min))}else{aF=aG.scale=w/Math.abs(aD(aG.max)-aD(aG.min));aF=-aF;aB=Math.max(aD(aG.max),aD(aG.min))}if(aD==aC){aG.p2c=function(aH){return(aH-aB)*aF}}else{aG.p2c=function(aH){return(aD(aH)-aB)*aF}}if(!aE){aG.c2p=function(aH){return aB+aH/aF}}else{aG.c2p=function(aH){return aE(aB+aH/aF)}}}function L(aD){var aB=aD.options,aF,aJ=aD.ticks||[],aI=[],aE,aK=aB.labelWidth,aG=aB.labelHeight,aC;function aH(aM,aL){return c('<div style="position:absolute;top:-10000px;'+aL+'font-size:smaller"><div class="'+aD.direction+"Axis "+aD.direction+aD.n+'Axis">'+aM.join("")+"</div></div>").appendTo(av)}if(aD.direction=="x"){if(aK==null){aK=Math.floor(G/(aJ.length>0?aJ.length:1))}if(aG==null){aI=[];for(aF=0;aF<aJ.length;++aF){aE=aJ[aF].label;if(aE){aI.push('<div class="tickLabel" style="float:left;width:'+aK+'px">'+aE+"</div>")}}if(aI.length>0){aI.push('<div style="clear:left"></div>');aC=aH(aI,"width:10000px;");aG=aC.height();aC.remove()}}}else{if(aK==null||aG==null){for(aF=0;aF<aJ.length;++aF){aE=aJ[aF].label;if(aE){aI.push('<div class="tickLabel">'+aE+"</div>")}}if(aI.length>0){aC=aH(aI,"");if(aK==null){aK=aC.children().width()}if(aG==null){aG=aC.find("div.tickLabel").height()}aC.remove()}}}if(aK==null){aK=0}if(aG==null){aG=0}aD.labelWidth=aK;aD.labelHeight=aG}function au(aD){var aC=aD.labelWidth,aL=aD.labelHeight,aH=aD.options.position,aF=aD.options.tickLength,aG=O.grid.axisMargin,aJ=O.grid.labelMargin,aK=aD.direction=="x"?p:aw,aE;var aB=c.grep(aK,function(aN){return aN&&aN.options.position==aH&&aN.reserveSpace});if(c.inArray(aD,aB)==aB.length-1){aG=0}if(aF==null){aF="full"}var aI=c.grep(aK,function(aN){return aN&&aN.reserveSpace});var aM=c.inArray(aD,aI)==0;if(!aM&&aF=="full"){aF=5}if(!isNaN(+aF)){aJ+=+aF}if(aD.direction=="x"){aL+=aJ;if(aH=="bottom"){q.bottom+=aL+aG;aD.box={top:I-q.bottom,height:aL}}else{aD.box={top:q.top+aG,height:aL};q.top+=aL+aG}}else{aC+=aJ;if(aH=="left"){aD.box={left:q.left+aG,width:aC};q.left+=aC+aG}else{q.right+=aC+aG;aD.box={left:G-q.right,width:aC}}}aD.position=aH;aD.tickLength=aF;aD.box.padding=aJ;aD.innermost=aM}function U(aB){if(aB.direction=="x"){aB.box.left=q.left;aB.box.width=h}else{aB.box.top=q.top;aB.box.height=w}}function t(){var aC,aE=m();c.each(aE,function(aF,aG){aG.show=aG.options.show;if(aG.show==null){aG.show=aG.used}aG.reserveSpace=aG.show||aG.options.reserveSpace;n(aG)});allocatedAxes=c.grep(aE,function(aF){return aF.reserveSpace});q.left=q.right=q.top=q.bottom=0;if(O.grid.show){c.each(allocatedAxes,function(aF,aG){S(aG);P(aG);ap(aG,aG.ticks);L(aG)});for(aC=allocatedAxes.length-1;aC>=0;--aC){au(allocatedAxes[aC])}var aD=O.grid.minBorderMargin;if(aD==null){aD=0;for(aC=0;aC<Q.length;++aC){aD=Math.max(aD,Q[aC].points.radius+Q[aC].points.lineWidth/2)}}for(var aB in q){q[aB]+=O.grid.borderWidth;q[aB]=Math.max(aD,q[aB])}}h=G-q.left-q.right;w=I-q.bottom-q.top;c.each(aE,function(aF,aG){r(aG)});if(O.grid.show){c.each(allocatedAxes,function(aF,aG){U(aG)});k()}o()}function n(aE){var aF=aE.options,aD=+(aF.min!=null?aF.min:aE.datamin),aB=+(aF.max!=null?aF.max:aE.datamax),aH=aB-aD;if(aH==0){var aC=aB==0?1:0.01;if(aF.min==null){aD-=aC}if(aF.max==null||aF.min!=null){aB+=aC}}else{var aG=aF.autoscaleMargin;if(aG!=null){if(aF.min==null){aD-=aH*aG;if(aD<0&&aE.datamin!=null&&aE.datamin>=0){aD=0}}if(aF.max==null){aB+=aH*aG;if(aB>0&&aE.datamax!=null&&aE.datamax<=0){aB=0}}}}aE.min=aD;aE.max=aB}function S(aG){var aM=aG.options;var aH;if(typeof aM.ticks=="number"&&aM.ticks>0){aH=aM.ticks}else{aH=0.3*Math.sqrt(aG.direction=="x"?G:I)}var aT=(aG.max-aG.min)/aH,aO,aB,aN,aR,aS,aQ,aI;if(aM.mode=="time"){var aJ={second:1000,minute:60*1000,hour:60*60*1000,day:24*60*60*1000,month:30*24*60*60*1000,year:365.2425*24*60*60*1000};var aK=[[1,"second"],[2,"second"],[5,"second"],[10,"second"],[30,"second"],[1,"minute"],[2,"minute"],[5,"minute"],[10,"minute"],[30,"minute"],[1,"hour"],[2,"hour"],[4,"hour"],[8,"hour"],[12,"hour"],[1,"day"],[2,"day"],[3,"day"],[0.25,"month"],[0.5,"month"],[1,"month"],[2,"month"],[3,"month"],[6,"month"],[1,"year"]];var aC=0;if(aM.minTickSize!=null){if(typeof aM.tickSize=="number"){aC=aM.tickSize}else{aC=aM.minTickSize[0]*aJ[aM.minTickSize[1]]}}for(var aS=0;aS<aK.length-1;++aS){if(aT<(aK[aS][0]*aJ[aK[aS][1]]+aK[aS+1][0]*aJ[aK[aS+1][1]])/2&&aK[aS][0]*aJ[aK[aS][1]]>=aC){break}}aO=aK[aS][0];aN=aK[aS][1];if(aN=="year"){aQ=Math.pow(10,Math.floor(Math.log(aT/aJ.year)/Math.LN10));aI=(aT/aJ.year)/aQ;if(aI<1.5){aO=1}else{if(aI<3){aO=2}else{if(aI<7.5){aO=5}else{aO=10}}}aO*=aQ}aG.tickSize=aM.tickSize||[aO,aN];aB=function(aX){var a2=[],a0=aX.tickSize[0],a3=aX.tickSize[1],a1=new Date(aX.min);var aW=a0*aJ[a3];if(a3=="second"){a1.setUTCSeconds(a(a1.getUTCSeconds(),a0))}if(a3=="minute"){a1.setUTCMinutes(a(a1.getUTCMinutes(),a0))}if(a3=="hour"){a1.setUTCHours(a(a1.getUTCHours(),a0))}if(a3=="month"){a1.setUTCMonth(a(a1.getUTCMonth(),a0))}if(a3=="year"){a1.setUTCFullYear(a(a1.getUTCFullYear(),a0))}a1.setUTCMilliseconds(0);if(aW>=aJ.minute){a1.setUTCSeconds(0)}if(aW>=aJ.hour){a1.setUTCMinutes(0)}if(aW>=aJ.day){a1.setUTCHours(0)}if(aW>=aJ.day*4){a1.setUTCDate(1)}if(aW>=aJ.year){a1.setUTCMonth(0)}var a5=0,a4=Number.NaN,aY;do{aY=a4;a4=a1.getTime();a2.push(a4);if(a3=="month"){if(a0<1){a1.setUTCDate(1);var aV=a1.getTime();a1.setUTCMonth(a1.getUTCMonth()+1);var aZ=a1.getTime();a1.setTime(a4+a5*aJ.hour+(aZ-aV)*a0);a5=a1.getUTCHours();a1.setUTCHours(0)}else{a1.setUTCMonth(a1.getUTCMonth()+a0)}}else{if(a3=="year"){a1.setUTCFullYear(a1.getUTCFullYear()+a0)}else{a1.setTime(a4+aW)}}}while(a4<aX.max&&a4!=aY);return a2};aR=function(aV,aY){var a0=new Date(aV);if(aM.timeformat!=null){return c.plot.formatDate(a0,aM.timeformat,aM.monthNames)}var aW=aY.tickSize[0]*aJ[aY.tickSize[1]];var aX=aY.max-aY.min;var aZ=(aM.twelveHourClock)?" %p":"";if(aW<aJ.minute){fmt="%h:%M:%S"+aZ}else{if(aW<aJ.day){if(aX<2*aJ.day){fmt="%h:%M"+aZ}else{fmt="%b %d %h:%M"+aZ}}else{if(aW<aJ.month){fmt="%b %d"}else{if(aW<aJ.year){if(aX<aJ.year){fmt="%b"}else{fmt="%b %y"}}else{fmt="%y"}}}}return c.plot.formatDate(a0,fmt,aM.monthNames)}}else{var aU=aM.tickDecimals;var aP=-Math.floor(Math.log(aT)/Math.LN10);if(aU!=null&&aP>aU){aP=aU}aQ=Math.pow(10,-aP);aI=aT/aQ;if(aI<1.5){aO=1}else{if(aI<3){aO=2;if(aI>2.25&&(aU==null||aP+1<=aU)){aO=2.5;++aP}}else{if(aI<7.5){aO=5}else{aO=10}}}aO*=aQ;if(aM.minTickSize!=null&&aO<aM.minTickSize){aO=aM.minTickSize}aG.tickDecimals=Math.max(0,aU!=null?aU:aP);aG.tickSize=aM.tickSize||aO;aB=function(aX){var aZ=[];var a0=a(aX.min,aX.tickSize),aW=0,aV=Number.NaN,aY;do{aY=aV;aV=a0+aW*aX.tickSize;aZ.push(aV);++aW}while(aV<aX.max&&aV!=aY);return aZ};aR=function(aV,aW){return aV.toFixed(aW.tickDecimals)}}if(aM.alignTicksWithAxis!=null){var aF=(aG.direction=="x"?p:aw)[aM.alignTicksWithAxis-1];if(aF&&aF.used&&aF!=aG){var aL=aB(aG);if(aL.length>0){if(aM.min==null){aG.min=Math.min(aG.min,aL[0])}if(aM.max==null&&aL.length>1){aG.max=Math.max(aG.max,aL[aL.length-1])}}aB=function(aX){var aY=[],aV,aW;for(aW=0;aW<aF.ticks.length;++aW){aV=(aF.ticks[aW].v-aF.min)/(aF.max-aF.min);aV=aX.min+aV*(aX.max-aX.min);aY.push(aV)}return aY};if(aG.mode!="time"&&aM.tickDecimals==null){var aE=Math.max(0,-Math.floor(Math.log(aT)/Math.LN10)+1),aD=aB(aG);if(!(aD.length>1&&/\..*0$/.test((aD[1]-aD[0]).toFixed(aE)))){aG.tickDecimals=aE}}}}aG.tickGenerator=aB;if(c.isFunction(aM.tickFormatter)){aG.tickFormatter=function(aV,aW){return""+aM.tickFormatter(aV,aW)}}else{aG.tickFormatter=aR}}function P(aF){var aH=aF.options.ticks,aG=[];if(aH==null||(typeof aH=="number"&&aH>0)){aG=aF.tickGenerator(aF)}else{if(aH){if(c.isFunction(aH)){aG=aH({min:aF.min,max:aF.max})}else{aG=aH}}}var aE,aB;aF.ticks=[];for(aE=0;aE<aG.length;++aE){var aC=null;var aD=aG[aE];if(typeof aD=="object"){aB=+aD[0];if(aD.length>1){aC=aD[1]}}else{aB=+aD}if(aC==null){aC=aF.tickFormatter(aB,aF)}if(!isNaN(aB)){aF.ticks.push({v:aB,label:aC})}}}function ap(aB,aC){if(aB.options.autoscaleMargin&&aC.length>0){if(aB.options.min==null){aB.min=Math.min(aB.min,aC[0].v)}if(aB.options.max==null&&aC.length>1){aB.max=Math.max(aB.max,aC[aC.length-1].v)}}}function W(){H.clearRect(0,0,G,I);var aC=O.grid;if(aC.show&&aC.backgroundColor){N()}if(aC.show&&!aC.aboveData){ac()}for(var aB=0;aB<Q.length;++aB){an(ak.drawSeries,[H,Q[aB]]);d(Q[aB])}an(ak.draw,[H]);if(aC.show&&aC.aboveData){ac()}}function D(aB,aI){var aE,aH,aG,aD,aF=m();for(i=0;i<aF.length;++i){aE=aF[i];if(aE.direction==aI){aD=aI+aE.n+"axis";if(!aB[aD]&&aE.n==1){aD=aI+"axis"}if(aB[aD]){aH=aB[aD].from;aG=aB[aD].to;break}}}if(!aB[aD]){aE=aI=="x"?p[0]:aw[0];aH=aB[aI+"1"];aG=aB[aI+"2"]}if(aH!=null&&aG!=null&&aH>aG){var aC=aH;aH=aG;aG=aC}return{from:aH,to:aG,axis:aE}}function N(){H.save();H.translate(q.left,q.top);H.fillStyle=am(O.grid.backgroundColor,w,0,"rgba(255, 255, 255, 0)");H.fillRect(0,0,h,w);H.restore()}function ac(){var aF;H.save();H.translate(q.left,q.top);var aH=O.grid.markings;if(aH){if(c.isFunction(aH)){var aK=aq.getAxes();aK.xmin=aK.xaxis.min;aK.xmax=aK.xaxis.max;aK.ymin=aK.yaxis.min;aK.ymax=aK.yaxis.max;aH=aH(aK)}for(aF=0;aF<aH.length;++aF){var aD=aH[aF],aC=D(aD,"x"),aI=D(aD,"y");if(aC.from==null){aC.from=aC.axis.min}if(aC.to==null){aC.to=aC.axis.max}if(aI.from==null){aI.from=aI.axis.min}if(aI.to==null){aI.to=aI.axis.max}if(aC.to<aC.axis.min||aC.from>aC.axis.max||aI.to<aI.axis.min||aI.from>aI.axis.max){continue}aC.from=Math.max(aC.from,aC.axis.min);aC.to=Math.min(aC.to,aC.axis.max);aI.from=Math.max(aI.from,aI.axis.min);aI.to=Math.min(aI.to,aI.axis.max);if(aC.from==aC.to&&aI.from==aI.to){continue}aC.from=aC.axis.p2c(aC.from);aC.to=aC.axis.p2c(aC.to);aI.from=aI.axis.p2c(aI.from);aI.to=aI.axis.p2c(aI.to);if(aC.from==aC.to||aI.from==aI.to){H.beginPath();H.strokeStyle=aD.color||O.grid.markingsColor;H.lineWidth=aD.lineWidth||O.grid.markingsLineWidth;H.moveTo(aC.from,aI.from);H.lineTo(aC.to,aI.to);H.stroke()}else{H.fillStyle=aD.color||O.grid.markingsColor;H.fillRect(aC.from,aI.to,aC.to-aC.from,aI.from-aI.to)}}}var aK=m(),aM=O.grid.borderWidth;for(var aE=0;aE<aK.length;++aE){var aB=aK[aE],aG=aB.box,aQ=aB.tickLength,aN,aL,aP,aJ;if(!aB.show||aB.ticks.length==0){continue}H.strokeStyle=aB.options.tickColor||c.color.parse(aB.options.color).scale("a",0.22).toString();H.lineWidth=1;if(aB.direction=="x"){aN=0;if(aQ=="full"){aL=(aB.position=="top"?0:w)}else{aL=aG.top-q.top+(aB.position=="top"?aG.height:0)}}else{aL=0;if(aQ=="full"){aN=(aB.position=="left"?0:h)}else{aN=aG.left-q.left+(aB.position=="left"?aG.width:0)}}if(!aB.innermost){H.beginPath();aP=aJ=0;if(aB.direction=="x"){aP=h}else{aJ=w}if(H.lineWidth==1){aN=Math.floor(aN)+0.5;aL=Math.floor(aL)+0.5}H.moveTo(aN,aL);H.lineTo(aN+aP,aL+aJ);H.stroke()}H.beginPath();for(aF=0;aF<aB.ticks.length;++aF){var aO=aB.ticks[aF].v;aP=aJ=0;if(aO<aB.min||aO>aB.max||(aQ=="full"&&aM>0&&(aO==aB.min||aO==aB.max))){continue}if(aB.direction=="x"){aN=aB.p2c(aO);aJ=aQ=="full"?-w:aQ;if(aB.position=="top"){aJ=-aJ}}else{aL=aB.p2c(aO);aP=aQ=="full"?-h:aQ;if(aB.position=="left"){aP=-aP}}if(H.lineWidth==1){if(aB.direction=="x"){aN=Math.floor(aN)+0.5}else{aL=Math.floor(aL)+0.5}}H.moveTo(aN,aL);H.lineTo(aN+aP,aL+aJ)}H.stroke()}if(aM){H.lineWidth=aM;H.strokeStyle=O.grid.borderColor;H.strokeRect(-aM/2,-aM/2,h+aM,w+aM)}H.restore()}function k(){av.find(".tickLabels").remove();var aG=['<div class="tickLabels" style="font-size:smaller">'];var aJ=m();for(var aD=0;aD<aJ.length;++aD){var aC=aJ[aD],aF=aC.box;if(!aC.show){continue}aG.push('<div class="'+aC.direction+"Axis "+aC.direction+aC.n+'Axis" style="color:'+aC.options.color+'">');for(var aE=0;aE<aC.ticks.length;++aE){var aH=aC.ticks[aE];if(!aH.label||aH.v<aC.min||aH.v>aC.max){continue}var aK={},aI;if(aC.direction=="x"){aI="center";aK.left=Math.round(q.left+aC.p2c(aH.v)-aC.labelWidth/2);if(aC.position=="bottom"){aK.top=aF.top+aF.padding}else{aK.bottom=I-(aF.top+aF.height-aF.padding)}}else{aK.top=Math.round(q.top+aC.p2c(aH.v)-aC.labelHeight/2);if(aC.position=="left"){aK.right=G-(aF.left+aF.width-aF.padding);aI="right"}else{aK.left=aF.left+aF.padding;aI="left"}}aK.width=aC.labelWidth;var aB=["position:absolute","text-align:"+aI];for(var aL in aK){aB.push(aL+":"+aK[aL]+"px")}aG.push('<div class="tickLabel" style="'+aB.join(";")+'">'+aH.label+"</div>")}aG.push("</div>")}aG.push("</div>");av.append(aG.join(""))}function d(aB){if(aB.lines.show){at(aB)}if(aB.bars.show){e(aB)}if(aB.points.show){ao(aB)}}function at(aE){function aD(aP,aQ,aI,aU,aT){var aV=aP.points,aJ=aP.pointsize,aN=null,aM=null;H.beginPath();for(var aO=aJ;aO<aV.length;aO+=aJ){var aL=aV[aO-aJ],aS=aV[aO-aJ+1],aK=aV[aO],aR=aV[aO+1];if(aL==null||aK==null){continue}if(aS<=aR&&aS<aT.min){if(aR<aT.min){continue}aL=(aT.min-aS)/(aR-aS)*(aK-aL)+aL;aS=aT.min}else{if(aR<=aS&&aR<aT.min){if(aS<aT.min){continue}aK=(aT.min-aS)/(aR-aS)*(aK-aL)+aL;aR=aT.min}}if(aS>=aR&&aS>aT.max){if(aR>aT.max){continue}aL=(aT.max-aS)/(aR-aS)*(aK-aL)+aL;aS=aT.max}else{if(aR>=aS&&aR>aT.max){if(aS>aT.max){continue}aK=(aT.max-aS)/(aR-aS)*(aK-aL)+aL;aR=aT.max}}if(aL<=aK&&aL<aU.min){if(aK<aU.min){continue}aS=(aU.min-aL)/(aK-aL)*(aR-aS)+aS;aL=aU.min}else{if(aK<=aL&&aK<aU.min){if(aL<aU.min){continue}aR=(aU.min-aL)/(aK-aL)*(aR-aS)+aS;aK=aU.min}}if(aL>=aK&&aL>aU.max){if(aK>aU.max){continue}aS=(aU.max-aL)/(aK-aL)*(aR-aS)+aS;aL=aU.max}else{if(aK>=aL&&aK>aU.max){if(aL>aU.max){continue}aR=(aU.max-aL)/(aK-aL)*(aR-aS)+aS;aK=aU.max}}if(aL!=aN||aS!=aM){H.moveTo(aU.p2c(aL)+aQ,aT.p2c(aS)+aI)}aN=aK;aM=aR;H.lineTo(aU.p2c(aK)+aQ,aT.p2c(aR)+aI)}H.stroke()}function aF(aI,aQ,aP){var aW=aI.points,aV=aI.pointsize,aN=Math.min(Math.max(0,aP.min),aP.max),aX=0,aU,aT=false,aM=1,aL=0,aR=0;while(true){if(aV>0&&aX>aW.length+aV){break}aX+=aV;var aZ=aW[aX-aV],aK=aW[aX-aV+aM],aY=aW[aX],aJ=aW[aX+aM];if(aT){if(aV>0&&aZ!=null&&aY==null){aR=aX;aV=-aV;aM=2;continue}if(aV<0&&aX==aL+aV){H.fill();aT=false;aV=-aV;aM=1;aX=aL=aR+aV;continue}}if(aZ==null||aY==null){continue}if(aZ<=aY&&aZ<aQ.min){if(aY<aQ.min){continue}aK=(aQ.min-aZ)/(aY-aZ)*(aJ-aK)+aK;aZ=aQ.min}else{if(aY<=aZ&&aY<aQ.min){if(aZ<aQ.min){continue}aJ=(aQ.min-aZ)/(aY-aZ)*(aJ-aK)+aK;aY=aQ.min}}if(aZ>=aY&&aZ>aQ.max){if(aY>aQ.max){continue}aK=(aQ.max-aZ)/(aY-aZ)*(aJ-aK)+aK;aZ=aQ.max}else{if(aY>=aZ&&aY>aQ.max){if(aZ>aQ.max){continue}aJ=(aQ.max-aZ)/(aY-aZ)*(aJ-aK)+aK;aY=aQ.max}}if(!aT){H.beginPath();H.moveTo(aQ.p2c(aZ),aP.p2c(aN));aT=true}if(aK>=aP.max&&aJ>=aP.max){H.lineTo(aQ.p2c(aZ),aP.p2c(aP.max));H.lineTo(aQ.p2c(aY),aP.p2c(aP.max));continue}else{if(aK<=aP.min&&aJ<=aP.min){H.lineTo(aQ.p2c(aZ),aP.p2c(aP.min));H.lineTo(aQ.p2c(aY),aP.p2c(aP.min));continue}}var aO=aZ,aS=aY;if(aK<=aJ&&aK<aP.min&&aJ>=aP.min){aZ=(aP.min-aK)/(aJ-aK)*(aY-aZ)+aZ;aK=aP.min}else{if(aJ<=aK&&aJ<aP.min&&aK>=aP.min){aY=(aP.min-aK)/(aJ-aK)*(aY-aZ)+aZ;aJ=aP.min}}if(aK>=aJ&&aK>aP.max&&aJ<=aP.max){aZ=(aP.max-aK)/(aJ-aK)*(aY-aZ)+aZ;aK=aP.max}else{if(aJ>=aK&&aJ>aP.max&&aK<=aP.max){aY=(aP.max-aK)/(aJ-aK)*(aY-aZ)+aZ;aJ=aP.max}}if(aZ!=aO){H.lineTo(aQ.p2c(aO),aP.p2c(aK))}H.lineTo(aQ.p2c(aZ),aP.p2c(aK));H.lineTo(aQ.p2c(aY),aP.p2c(aJ));if(aY!=aS){H.lineTo(aQ.p2c(aY),aP.p2c(aJ));H.lineTo(aQ.p2c(aS),aP.p2c(aJ))}}}H.save();H.translate(q.left,q.top);H.lineJoin="round";var aG=aE.lines.lineWidth,aB=aE.shadowSize;if(aG>0&&aB>0){H.lineWidth=aB;H.strokeStyle="rgba(0,0,0,0.1)";var aH=Math.PI/18;aD(aE.datapoints,Math.sin(aH)*(aG/2+aB/2),Math.cos(aH)*(aG/2+aB/2),aE.xaxis,aE.yaxis);H.lineWidth=aB/2;aD(aE.datapoints,Math.sin(aH)*(aG/2+aB/4),Math.cos(aH)*(aG/2+aB/4),aE.xaxis,aE.yaxis)}H.lineWidth=aG;H.strokeStyle=aE.color;var aC=ae(aE.lines,aE.color,0,w);if(aC){H.fillStyle=aC;aF(aE.datapoints,aE.xaxis,aE.yaxis)}if(aG>0){aD(aE.datapoints,0,0,aE.xaxis,aE.yaxis)}H.restore()}function ao(aE){function aH(aN,aM,aU,aK,aS,aT,aQ,aJ){var aR=aN.points,aI=aN.pointsize;for(var aL=0;aL<aR.length;aL+=aI){var aP=aR[aL],aO=aR[aL+1];if(aP==null||aP<aT.min||aP>aT.max||aO<aQ.min||aO>aQ.max){continue}H.beginPath();aP=aT.p2c(aP);aO=aQ.p2c(aO)+aK;if(aJ=="circle"){H.arc(aP,aO,aM,0,aS?Math.PI:Math.PI*2,false)}else{aJ(H,aP,aO,aM,aS)}H.closePath();if(aU){H.fillStyle=aU;H.fill()}H.stroke()}}H.save();H.translate(q.left,q.top);var aG=aE.points.lineWidth,aC=aE.shadowSize,aB=aE.points.radius,aF=aE.points.symbol;if(aG>0&&aC>0){var aD=aC/2;H.lineWidth=aD;H.strokeStyle="rgba(0,0,0,0.1)";aH(aE.datapoints,aB,null,aD+aD/2,true,aE.xaxis,aE.yaxis,aF);H.strokeStyle="rgba(0,0,0,0.2)";aH(aE.datapoints,aB,null,aD/2,true,aE.xaxis,aE.yaxis,aF)}H.lineWidth=aG;H.strokeStyle=aE.color;aH(aE.datapoints,aB,ae(aE.points,aE.color),0,false,aE.xaxis,aE.yaxis,aF);H.restore()}function E(aN,aM,aV,aI,aQ,aF,aD,aL,aK,aU,aR,aC){var aE,aT,aJ,aP,aG,aB,aO,aH,aS;if(aR){aH=aB=aO=true;aG=false;aE=aV;aT=aN;aP=aM+aI;aJ=aM+aQ;if(aT<aE){aS=aT;aT=aE;aE=aS;aG=true;aB=false}}else{aG=aB=aO=true;aH=false;aE=aN+aI;aT=aN+aQ;aJ=aV;aP=aM;if(aP<aJ){aS=aP;aP=aJ;aJ=aS;aH=true;aO=false}}if(aT<aL.min||aE>aL.max||aP<aK.min||aJ>aK.max){return}if(aE<aL.min){aE=aL.min;aG=false}if(aT>aL.max){aT=aL.max;aB=false}if(aJ<aK.min){aJ=aK.min;aH=false}if(aP>aK.max){aP=aK.max;aO=false}aE=aL.p2c(aE);aJ=aK.p2c(aJ);aT=aL.p2c(aT);aP=aK.p2c(aP);if(aD){aU.beginPath();aU.moveTo(aE,aJ);aU.lineTo(aE,aP);aU.lineTo(aT,aP);aU.lineTo(aT,aJ);aU.fillStyle=aD(aJ,aP);aU.fill()}if(aC>0&&(aG||aB||aO||aH)){aU.beginPath();aU.moveTo(aE,aJ+aF);if(aG){aU.lineTo(aE,aP+aF)}else{aU.moveTo(aE,aP+aF)}if(aO){aU.lineTo(aT,aP+aF)}else{aU.moveTo(aT,aP+aF)}if(aB){aU.lineTo(aT,aJ+aF)}else{aU.moveTo(aT,aJ+aF)}if(aH){aU.lineTo(aE,aJ+aF)}else{aU.moveTo(aE,aJ+aF)}aU.stroke()}}function e(aD){function aC(aJ,aI,aL,aG,aK,aN,aM){var aO=aJ.points,aF=aJ.pointsize;for(var aH=0;aH<aO.length;aH+=aF){if(aO[aH]==null){continue}E(aO[aH],aO[aH+1],aO[aH+2],aI,aL,aG,aK,aN,aM,H,aD.bars.horizontal,aD.bars.lineWidth)}}H.save();H.translate(q.left,q.top);H.lineWidth=aD.bars.lineWidth;H.strokeStyle=aD.color;var aB=aD.bars.align=="left"?0:-aD.bars.barWidth/2;var aE=aD.bars.fill?function(aF,aG){return ae(aD.bars,aD.color,aF,aG)}:null;aC(aD.datapoints,aB,aB+aD.bars.barWidth,0,aE,aD.xaxis,aD.yaxis);H.restore()}function ae(aD,aB,aC,aF){var aE=aD.fill;if(!aE){return null}if(aD.fillColor){return am(aD.fillColor,aC,aF,aB)}var aG=c.color.parse(aB);aG.a=typeof aE=="number"?aE:0.4;aG.normalize();return aG.toString()}function o(){av.find(".legend").remove();if(!O.legend.show){return}var aH=[],aF=false,aN=O.legend.labelFormatter,aM,aJ;for(var aE=0;aE<Q.length;++aE){aM=Q[aE];aJ=aM.label;if(!aJ){continue}if(aE%O.legend.noColumns==0){if(aF){aH.push("</tr>")}aH.push("<tr>");aF=true}if(aN){aJ=aN(aJ,aM)}aH.push('<td class="legendColorBox"><div style="border:1px solid '+O.legend.labelBoxBorderColor+';padding:1px"><div style="width:4px;height:0;border:5px solid '+aM.color+';overflow:hidden"></div></div></td><td class="legendLabel">'+aJ+"</td>")}if(aF){aH.push("</tr>")}if(aH.length==0){return}var aL='<table style="font-size:smaller;color:'+O.grid.color+'">'+aH.join("")+"</table>";if(O.legend.container!=null){c(O.legend.container).html(aL)}else{var aI="",aC=O.legend.position,aD=O.legend.margin;if(aD[0]==null){aD=[aD,aD]}if(aC.charAt(0)=="n"){aI+="top:"+(aD[1]+q.top)+"px;"}else{if(aC.charAt(0)=="s"){aI+="bottom:"+(aD[1]+q.bottom)+"px;"}}if(aC.charAt(1)=="e"){aI+="right:"+(aD[0]+q.right)+"px;"}else{if(aC.charAt(1)=="w"){aI+="left:"+(aD[0]+q.left)+"px;"}}var aK=c('<div class="legend">'+aL.replace('style="','style="position:absolute;'+aI+";")+"</div>").appendTo(av);if(O.legend.backgroundOpacity!=0){var aG=O.legend.backgroundColor;if(aG==null){aG=O.grid.backgroundColor;if(aG&&typeof aG=="string"){aG=c.color.parse(aG)}else{aG=c.color.extract(aK,"background-color")}aG.a=1;aG=aG.toString()}var aB=aK.children();c('<div style="position:absolute;width:'+aB.width()+"px;height:"+aB.height()+"px;"+aI+"background-color:"+aG+';"> </div>').prependTo(aK).css("opacity",O.legend.backgroundOpacity)}}}var ab=[],M=null;function K(aI,aG,aD){var aO=O.grid.mouseActiveRadius,a0=aO*aO+1,aY=null,aR=false,aW,aU;for(aW=Q.length-1;aW>=0;--aW){if(!aD(Q[aW])){continue}var aP=Q[aW],aH=aP.xaxis,aF=aP.yaxis,aV=aP.datapoints.points,aT=aP.datapoints.pointsize,aQ=aH.c2p(aI),aN=aF.c2p(aG),aC=aO/aH.scale,aB=aO/aF.scale;if(aH.options.inverseTransform){aC=Number.MAX_VALUE}if(aF.options.inverseTransform){aB=Number.MAX_VALUE}if(aP.lines.show||aP.points.show){for(aU=0;aU<aV.length;aU+=aT){var aK=aV[aU],aJ=aV[aU+1];if(aK==null){continue}if(aK-aQ>aC||aK-aQ<-aC||aJ-aN>aB||aJ-aN<-aB){continue}var aM=Math.abs(aH.p2c(aK)-aI),aL=Math.abs(aF.p2c(aJ)-aG),aS=aM*aM+aL*aL;if(aS<a0){a0=aS;aY=[aW,aU/aT]}}}if(aP.bars.show&&!aY){var aE=aP.bars.align=="left"?0:-aP.bars.barWidth/2,aX=aE+aP.bars.barWidth;for(aU=0;aU<aV.length;aU+=aT){var aK=aV[aU],aJ=aV[aU+1],aZ=aV[aU+2];if(aK==null){continue}if(Q[aW].bars.horizontal?(aQ<=Math.max(aZ,aK)&&aQ>=Math.min(aZ,aK)&&aN>=aJ+aE&&aN<=aJ+aX):(aQ>=aK+aE&&aQ<=aK+aX&&aN>=Math.min(aZ,aJ)&&aN<=Math.max(aZ,aJ))){aY=[aW,aU/aT]}}}}if(aY){aW=aY[0];aU=aY[1];aT=Q[aW].datapoints.pointsize;return{datapoint:Q[aW].datapoints.points.slice(aU*aT,(aU+1)*aT),dataIndex:aU,series:Q[aW],seriesIndex:aW}}return null}function aa(aB){if(O.grid.hoverable){u("plothover",aB,function(aC){return aC.hoverable!=false})}}function l(aB){if(O.grid.hoverable){u("plothover",aB,function(aC){return false})}}function R(aB){u("plotclick",aB,function(aC){return aC.clickable!=false})}function u(aC,aB,aD){var aE=y.offset(),aH=aB.pageX-aE.left-q.left,aF=aB.pageY-aE.top-q.top,aJ=C({left:aH,top:aF});aJ.pageX=aB.pageX;aJ.pageY=aB.pageY;var aK=K(aH,aF,aD);if(aK){aK.pageX=parseInt(aK.series.xaxis.p2c(aK.datapoint[0])+aE.left+q.left);aK.pageY=parseInt(aK.series.yaxis.p2c(aK.datapoint[1])+aE.top+q.top)}if(O.grid.autoHighlight){for(var aG=0;aG<ab.length;++aG){var aI=ab[aG];if(aI.auto==aC&&!(aK&&aI.series==aK.series&&aI.point[0]==aK.datapoint[0]&&aI.point[1]==aK.datapoint[1])){T(aI.series,aI.point)}}if(aK){x(aK.series,aK.datapoint,aC)}}av.trigger(aC,[aJ,aK])}function f(){if(!M){M=setTimeout(s,30)}}function s(){M=null;A.save();A.clearRect(0,0,G,I);A.translate(q.left,q.top);var aC,aB;for(aC=0;aC<ab.length;++aC){aB=ab[aC];if(aB.series.bars.show){v(aB.series,aB.point)}else{ay(aB.series,aB.point)}}A.restore();an(ak.drawOverlay,[A])}function x(aD,aB,aF){if(typeof aD=="number"){aD=Q[aD]}if(typeof aB=="number"){var aE=aD.datapoints.pointsize;aB=aD.datapoints.points.slice(aE*aB,aE*(aB+1))}var aC=al(aD,aB);if(aC==-1){ab.push({series:aD,point:aB,auto:aF});f()}else{if(!aF){ab[aC].auto=false}}}function T(aD,aB){if(aD==null&&aB==null){ab=[];f()}if(typeof aD=="number"){aD=Q[aD]}if(typeof aB=="number"){aB=aD.data[aB]}var aC=al(aD,aB);if(aC!=-1){ab.splice(aC,1);f()}}function al(aD,aE){for(var aB=0;aB<ab.length;++aB){var aC=ab[aB];if(aC.series==aD&&aC.point[0]==aE[0]&&aC.point[1]==aE[1]){return aB}}return -1}function ay(aE,aD){var aC=aD[0],aI=aD[1],aH=aE.xaxis,aG=aE.yaxis;if(aC<aH.min||aC>aH.max||aI<aG.min||aI>aG.max){return}var aF=aE.points.radius+aE.points.lineWidth/2;A.lineWidth=aF;A.strokeStyle=c.color.parse(aE.color).scale("a",0.5).toString();var aB=1.5*aF,aC=aH.p2c(aC),aI=aG.p2c(aI);A.beginPath();if(aE.points.symbol=="circle"){A.arc(aC,aI,aB,0,2*Math.PI,false)}else{aE.points.symbol(A,aC,aI,aB,false)}A.closePath();A.stroke()}function v(aE,aB){A.lineWidth=aE.bars.lineWidth;A.strokeStyle=c.color.parse(aE.color).scale("a",0.5).toString();var aD=c.color.parse(aE.color).scale("a",0.5).toString();var aC=aE.bars.align=="left"?0:-aE.bars.barWidth/2;E(aB[0],aB[1],aB[2]||0,aC,aC+aE.bars.barWidth,0,function(){return aD},aE.xaxis,aE.yaxis,A,aE.bars.horizontal,aE.bars.lineWidth)}function am(aJ,aB,aH,aC){if(typeof aJ=="string"){return aJ}else{var aI=H.createLinearGradient(0,aH,0,aB);for(var aE=0,aD=aJ.colors.length;aE<aD;++aE){var aF=aJ.colors[aE];if(typeof aF!="string"){var aG=c.color.parse(aC);if(aF.brightness!=null){aG=aG.scale("rgb",aF.brightness)}if(aF.opacity!=null){aG.a*=aF.opacity}aF=aG.toString()}aI.addColorStop(aE/(aD-1),aF)}return aI}}}c.plot=function(g,e,d){var f=new b(c(g),e,d,c.plot.plugins);return f};c.plot.version="0.7";c.plot.plugins=[];c.plot.formatDate=function(l,f,h){var o=function(d){d=""+d;return d.length==1?"0"+d:d};var e=[];var p=false,j=false;var n=l.getUTCHours();var k=n<12;if(h==null){h=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]}if(f.search(/%p|%P/)!=-1){if(n>12){n=n-12}else{if(n==0){n=12}}}for(var g=0;g<f.length;++g){var m=f.charAt(g);if(p){switch(m){case"h":m=""+n;break;case"H":m=o(n);break;case"M":m=o(l.getUTCMinutes());break;case"S":m=o(l.getUTCSeconds());break;case"d":m=""+l.getUTCDate();break;case"m":m=""+(l.getUTCMonth()+1);break;case"y":m=""+l.getUTCFullYear();break;case"b":m=""+h[l.getUTCMonth()];break;case"p":m=(k)?("am"):("pm");break;case"P":m=(k)?("AM"):("PM");break;case"0":m="";j=true;break}if(m&&j){m=o(m);j=false}e.push(m);if(!j){p=false}}else{if(m=="%"){p=true}else{e.push(m)}}}return e.join("")};function a(e,d){return d*Math.floor(e/d)}})(jQuery);
/*
 This code was begun by Bruce Sherwood (bruce.sherwood@gmail.com), May 2011, 
 to render an API based on that of VPython (vpython.org).
 
 Major restructuring by David Scherer, June 2011.
 
 Help from the following people is gratefully acknowledged:
 Greg Sonnenfeld, Owen Densmore, and Nicolas Garcia Belmonte.
 
 Feel free to use or modify this material for any purpose, but please retain this notice.
 */

function _vec(x,y,z) {
	this.x = x
	this.y = y
	this.z = z
	// This if statement fires whether or not z is present...??
	//if (!(z != undefined)) { throw new Error("vec requires 3 arguments, x, y, z") }
}

function vec(x,y,z) {
	if (arguments.length == 1 && x.x !== undefined) return x
	return new _vec(x,y,z)
}

function attributeVector(parent,x,y,z) {
	return new _attributeVector(parent,x,y,z)
}

function _attributeVector(parent,x,y,z) {
	this.__parent = parent
	this.__x = x
	this.__y = y
	this.__z = z
	parent.__change()
}

_attributeVector.prototype = new _vec()
_attributeVector.prototype.constructor = _attributeVector

Object.defineProperty(_attributeVector.prototype, '__x', { enumerable: false, writable: true, value: 0 })
Object.defineProperty(_attributeVector.prototype, 'x', {
	enumerable: true,
	get:
		function () { return this.__x },
	set:
		function (value) {
			this.__x = value;
			this.__parent.__change()
		}
});

Object.defineProperty(_attributeVector.prototype, '__y', { enumerable: false, writable: true, value: 0 })
Object.defineProperty(_attributeVector.prototype, 'y', {
	enumerable: true,
	get:
		function () { return this.__y },
	set:
		function (value) {
			this.__y = value;
			this.__parent.__change()
		}
});

Object.defineProperty(_attributeVector.prototype, '__z', { enumerable: false, writable: true, value: 0 })
Object.defineProperty(_attributeVector.prototype, 'z', {
	enumerable: true,
	get:
		function () { return this.__z },
	set:
		function (value) {
			this.__z = value;
			this.__parent.__change()
		}
});

_vec.prototype.toString = function () {
	// Mimics the vector display of VPython
	var input = [this.x, this.y, this.z]
	var output = []
	var c, eloc, period, char, end
	for (var i=0; i<3; i++) {
		var c = input[i]
		if (c == 0) {
			output.push('0')
			continue
		}
		if (Math.abs(c) < 1e-4) c = c.toExponential(5)
		else c = c.toPrecision(6)
		period = c.indexOf('.')
		if (period >= 0) {
			end = c.indexOf('e')
			if (end < 0) end = c.length
			char = end
			while (true) {
				char--
				if (c.charAt(char) == '0') continue
				if (char == period) {
					output.push(c.slice(0,period).concat(c.slice(end,c.length)))
					break
				}
				if (end == c.length) output.push(c.slice(0,char+1))
				else output.push(c.slice(0,char+1).concat(c.slice(end,c.length)))
				break
			}
		} else output.push(c)
	}
	return "< " + output[0] + ", " + output[1] + ", " + output[2] + " >"
}

_vec.prototype.add = function (v) {
    return vec(this.x+v.x, this.y+v.y, this.z+v.z) }
    
_vec.prototype.sub = function (v) {
    return vec(this.x-v.x, this.y-v.y, this.z-v.z) }
    
_vec.prototype.multiply = function (s) {
    return vec(this.x*s, this.y*s, this.z*s) }
    
_vec.prototype.divide = function (s) {
    return vec(this.x/s, this.y/s, this.z/s) }
    
_vec.prototype.mag = function () {
    return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z) }

_vec.prototype.mag2 = function () {
    return this.x * this.x + this.y * this.y + this.z * this.z
}    
_vec.prototype.norm = function () {
	var r = this.mag()
	if (r == 0) return new _vec(0,0,0)
    return vec(this.x/r, this.y/r, this.z/r) }
    
_vec.prototype.dot = function (v) {
    return this.x*v.x + this.y*v.y + this.z*v.z }
    
_vec.prototype.equal = function (v) {
    return (this.x == v.x && this.y == v.y && this.z == v.z) }
    
_vec.prototype.proj = function (v) {
	var B = norm(v)
    return B.multiply(this.dot(B))
}
    
_vec.prototype.comp = function (v) {
    return this.dot(norm(v)) }
    
_vec.prototype.cross = function (v) {
    return vec(
	    this.y*v.z - this.z*v.y, 
	    this.z*v.x - this.x*v.z, 
	    this.x*v.y - this.y*v.x) }
	    
_vec.prototype.diff_angle = function (v) {
	return Math.acos(this.norm().dot(v.norm())) }
	    
_vec.prototype.rotate = function (angle, axis) {
	if (axis === undefined) axis = vec(0,0,1)
	var theta = this.diff_angle(axis) 
	if (theta == 0) return new vec(this.x, this.y, this.z)
	axis = axis.norm()
	var parallel = axis.multiply(axis.dot(this)) // projection along axis
	var perp = axis.cross(this)
	var pmag = perp.mag() // length of 'this' projected onto plane perpendicular to axis
	perp = perp.norm()
	var y = perp.cross(axis) // y, perp, axis is an orthogonal coordinate system
	var rotated = y.multiply(pmag*Math.cos(angle)).add(perp.multiply(pmag*Math.sin(angle)))
	return parallel.add(rotated) }
    
vec.random = function() {
    return vec(-1+2*Math.random(), -1+2*Math.random(), -1+2*Math.random()) }

// Support operator overloading
String.prototype['+'] = function (r) { return this + r }
Number.prototype['+'] = function (r) { return this + r }
Number.prototype['-'] = function (r) { return this - r }
Number.prototype['*'] = function (r) { return r['*r'](this); }
Number.prototype['*r'] = function (l) { return l * this; }
Number.prototype['/'] = function (r) { return this / r }
Number.prototype["-u"] = function () { return -this }
_vec.prototype['+'] = _vec.prototype.add
_vec.prototype['-'] = _vec.prototype.sub
_vec.prototype['*'] = _vec.prototype.multiply
_vec.prototype['*r'] = _vec.prototype.multiply
_vec.prototype['/'] = function (r) { return this.divide(r) }
_vec.prototype["-u"] = function () { return vec(-this.x, -this.y, -this.z) }

/* 
* glMatrix.js - High performance matrix and vector operations for WebGL
* version 0.9.6
*/

/*
* Copyright (c) 2011 Brandon Jones
*
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
*    1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
*    2. Altered source versions must be plainly marked as such, and must not
*    be misrepresented as being the original software.
*
*    3. This notice may not be removed or altered from any source
*    distribution.
*/

// Fallback for systems that don't support WebGL
if (typeof Float32Array != 'undefined') {
    glMatrixArrayType = Float32Array;
} else if (typeof WebGLFloatArray != 'undefined') {
    glMatrixArrayType = WebGLFloatArray; // This is officially deprecated and should dissapear in future revisions.
} else {
    glMatrixArrayType = Array;
}

/*
* vec3 - 3 Dimensional Vector
*/
var vec3 = {};

/*
* vec3.create
* Creates a new instance of a vec3 using the default array type
* Any javascript array containing at least 3 numeric elements can serve as a vec3
*
* Params:
* vec - Optional, vec3 containing values to initialize with
*
* Returns:
* New vec3
*/
vec3.create = function (vec) {
    var dest = new glMatrixArrayType(3);

    if (vec) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];
    }

    return dest;
};

/*
* vec3.set
* Copies the values of one vec3 to another
*
* Params:
* vec - vec3 containing values to copy
* dest - vec3 receiving copied values
*
* Returns:
* dest
*/
vec3.set = function (vec, dest) {
    dest[0] = vec[0];
    dest[1] = vec[1];
    dest[2] = vec[2];

    return dest;
};

/*
* vec3.add
* Performs a vector addition
*
* Params:
* vec - vec3, first operand
* vec2 - vec3, second operand
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.add = function (vec, vec2, dest) {
    if (!dest || vec == dest) {
        vec[0] += vec2[0];
        vec[1] += vec2[1];
        vec[2] += vec2[2];
        return vec;
    }

    dest[0] = vec[0] + vec2[0];
    dest[1] = vec[1] + vec2[1];
    dest[2] = vec[2] + vec2[2];
    return dest;
};

/*
* vec3.subtract
* Performs a vector subtraction
*
* Params:
* vec - vec3, first operand
* vec2 - vec3, second operand
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.subtract = function (vec, vec2, dest) {
    if (!dest || vec == dest) {
        vec[0] -= vec2[0];
        vec[1] -= vec2[1];
        vec[2] -= vec2[2];
        return vec;
    }

    dest[0] = vec[0] - vec2[0];
    dest[1] = vec[1] - vec2[1];
    dest[2] = vec[2] - vec2[2];
    return dest;
};

/*
* vec3.negate
* Negates the components of a vec3
*
* Params:
* vec - vec3 to negate
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.negate = function (vec, dest) {
    if (!dest) { dest = vec; }

    dest[0] = -vec[0];
    dest[1] = -vec[1];
    dest[2] = -vec[2];
    return dest;
};

/*
* vec3.scale
* Multiplies the components of a vec3 by a scalar value
*
* Params:
* vec - vec3 to scale
* val - Numeric value to scale by
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.scale = function (vec, val, dest) {
    if (!dest || vec == dest) {
        vec[0] *= val;
        vec[1] *= val;
        vec[2] *= val;
        return vec;
    }

    dest[0] = vec[0] * val;
    dest[1] = vec[1] * val;
    dest[2] = vec[2] * val;
    return dest;
};

/*
* vec3.normalize
* Generates a unit vector of the same direction as the provided vec3
* If vector length is 0, returns [0, 0, 0]
*
* Params:
* vec - vec3 to normalize
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.normalize = function (vec, dest) {
    if (!dest) { dest = vec; }

    var x = vec[0], y = vec[1], z = vec[2];
    var len = Math.sqrt(x * x + y * y + z * z);

    if (!len) {
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        return dest;
    } else if (len == 1) {
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        return dest;
    }

    len = 1 / len;
    dest[0] = x * len;
    dest[1] = y * len;
    dest[2] = z * len;
    return dest;
};

/*
* vec3.cross
* Generates the cross product of two vec3s
*
* Params:
* vec - vec3, first operand
* vec2 - vec3, second operand
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.cross = function (vec, vec2, dest) {
    if (!dest) { dest = vec; }

    var x = vec[0], y = vec[1], z = vec[2];
    var x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

    dest[0] = y * z2 - z * y2;
    dest[1] = z * x2 - x * z2;
    dest[2] = x * y2 - y * x2;
    return dest;
};

/*
* vec3.length
* Caclulates the length of a vec3
*
* Params:
* vec - vec3 to calculate length of
*
* Returns:
* Length of vec
*/
vec3.length = function (vec) {
    var x = vec[0], y = vec[1], z = vec[2];
    return Math.sqrt(x * x + y * y + z * z);
};

/*
* vec3.dot
* Caclulates the dot product of two vec3s
*
* Params:
* vec - vec3, first operand
* vec2 - vec3, second operand
*
* Returns:
* Dot product of vec and vec2
*/
vec3.dot = function (vec, vec2) {
    return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
};

/*
* vec3.direction
* Generates a unit vector pointing from one vector to another
*
* Params:
* vec - origin vec3
* vec2 - vec3 to point to
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.direction = function (vec, vec2, dest) {
    if (!dest) { dest = vec; }

    var x = vec[0] - vec2[0];
    var y = vec[1] - vec2[1];
    var z = vec[2] - vec2[2];

    var len = Math.sqrt(x * x + y * y + z * z);
    if (!len) {
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        return dest;
    }

    len = 1 / len;
    dest[0] = x * len;
    dest[1] = y * len;
    dest[2] = z * len;
    return dest;
};

/*
* vec3.lerp
* Performs a linear interpolation between two vec3
*
* Params:
* vec - vec3, first vector
* vec2 - vec3, second vector
* lerp - interpolation amount between the two inputs
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
vec3.lerp = function (vec, vec2, lerp, dest) {
    if (!dest) { dest = vec; }

    dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
    dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
    dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

    return dest;
}

/*
* vec3.str
* Returns a string representation of a vector
*
* Params:
* vec - vec3 to represent as a string
*
* Returns:
* string representation of vec
*/
vec3.str = function (vec) {
    return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
};

/*
* mat3 - 3x3 Matrix
*/
var mat3 = {};

/*
* mat3.create
* Creates a new instance of a mat3 using the default array type
* Any javascript array containing at least 9 numeric elements can serve as a mat3
*
* Params:
* mat - Optional, mat3 containing values to initialize with
*
* Returns:
* New mat3
*/
mat3.create = function (mat) {
    var dest = new glMatrixArrayType(9);

    if (mat) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
    }

    return dest;
};

/*
* mat3.set
* Copies the values of one mat3 to another
*
* Params:
* mat - mat3 containing values to copy
* dest - mat3 receiving copied values
*
* Returns:
* dest
*/
mat3.set = function (mat, dest) {
    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[3];
    dest[4] = mat[4];
    dest[5] = mat[5];
    dest[6] = mat[6];
    dest[7] = mat[7];
    dest[8] = mat[8];
    return dest;
};

/*
* mat3.identity
* Sets a mat3 to an identity matrix
*
* Params:
* dest - mat3 to set
*
* Returns:
* dest
*/
mat3.identity = function (dest) {
    dest[0] = 1;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 1;
    dest[5] = 0;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = 1;
    return dest;
};

/*
* mat4.transpose
* Transposes a mat3 (flips the values over the diagonal)
*
* Params:
* mat - mat3 to transpose
* dest - Optional, mat3 receiving transposed values. If not specified result is written to mat
*
* Returns:
* dest is specified, mat otherwise
*/
mat3.transpose = function (mat, dest) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (!dest || mat == dest) {
        var a01 = mat[1], a02 = mat[2];
        var a12 = mat[5];

        mat[1] = mat[3];
        mat[2] = mat[6];
        mat[3] = a01;
        mat[5] = mat[7];
        mat[6] = a02;
        mat[7] = a12;
        return mat;
    }

    dest[0] = mat[0];
    dest[1] = mat[3];
    dest[2] = mat[6];
    dest[3] = mat[1];
    dest[4] = mat[4];
    dest[5] = mat[7];
    dest[6] = mat[2];
    dest[7] = mat[5];
    dest[8] = mat[8];
    return dest;
};

/*
* mat3.toMat4
* Copies the elements of a mat3 into the upper 3x3 elements of a mat4
*
* Params:
* mat - mat3 containing values to copy
* dest - Optional, mat4 receiving copied values
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
mat3.toMat4 = function (mat, dest) {
    if (!dest) { dest = mat4.create(); }

    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = 0;

    dest[4] = mat[3];
    dest[5] = mat[4];
    dest[6] = mat[5];
    dest[7] = 0;

    dest[8] = mat[6];
    dest[9] = mat[7];
    dest[10] = mat[8];
    dest[11] = 0;

    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;

    return dest;
}

/*
* mat3.str
* Returns a string representation of a mat3
*
* Params:
* mat - mat3 to represent as a string
*
* Returns:
* string representation of mat
*/
mat3.str = function (mat) {
    return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] +
                ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] +
                ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';
};

/*
* mat4 - 4x4 Matrix
*/
var mat4 = {};

/*
* mat4.create
* Creates a new instance of a mat4 using the default array type
* Any javascript array containing at least 16 numeric elements can serve as a mat4
*
* Params:
* mat - Optional, mat4 containing values to initialize with
*
* Returns:
* New mat4
*/
mat4.create = function (mat) {
    var dest = new glMatrixArrayType(16);

    if (mat) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
    }

    return dest;
};

/*
* mat4.set
* Copies the values of one mat4 to another
*
* Params:
* mat - mat4 containing values to copy
* dest - mat4 receiving copied values
*
* Returns:
* dest
*/
mat4.set = function (mat, dest) {
    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[3];
    dest[4] = mat[4];
    dest[5] = mat[5];
    dest[6] = mat[6];
    dest[7] = mat[7];
    dest[8] = mat[8];
    dest[9] = mat[9];
    dest[10] = mat[10];
    dest[11] = mat[11];
    dest[12] = mat[12];
    dest[13] = mat[13];
    dest[14] = mat[14];
    dest[15] = mat[15];
    return dest;
};

/*
* mat4.identity
* Sets a mat4 to an identity matrix
*
* Params:
* dest - mat4 to set
*
* Returns:
* dest
*/
mat4.identity = function (dest) {
    dest[0] = 1;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = 1;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = 0;
    dest[9] = 0;
    dest[10] = 1;
    dest[11] = 0;
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;
    return dest;
};

/*
* mat4.transpose
* Transposes a mat4 (flips the values over the diagonal)
*
* Params:
* mat - mat4 to transpose
* dest - Optional, mat4 receiving transposed values. If not specified result is written to mat
*
* Returns:
* dest is specified, mat otherwise
*/
mat4.transpose = function (mat, dest) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (!dest || mat == dest) {
        var a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a12 = mat[6], a13 = mat[7];
        var a23 = mat[11];

        mat[1] = mat[4];
        mat[2] = mat[8];
        mat[3] = mat[12];
        mat[4] = a01;
        mat[6] = mat[9];
        mat[7] = mat[13];
        mat[8] = a02;
        mat[9] = a12;
        mat[11] = mat[14];
        mat[12] = a03;
        mat[13] = a13;
        mat[14] = a23;
        return mat;
    }

    dest[0] = mat[0];
    dest[1] = mat[4];
    dest[2] = mat[8];
    dest[3] = mat[12];
    dest[4] = mat[1];
    dest[5] = mat[5];
    dest[6] = mat[9];
    dest[7] = mat[13];
    dest[8] = mat[2];
    dest[9] = mat[6];
    dest[10] = mat[10];
    dest[11] = mat[14];
    dest[12] = mat[3];
    dest[13] = mat[7];
    dest[14] = mat[11];
    dest[15] = mat[15];
    return dest;
};

/*
* mat4.determinant
* Calculates the determinant of a mat4
*
* Params:
* mat - mat4 to calculate determinant of
*
* Returns:
* determinant of mat
*/
mat4.determinant = function (mat) {
    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
    var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

    return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                        a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                        a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                        a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                        a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                        a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
};

/*
* mat4.inverse
* Calculates the inverse matrix of a mat4
*
* Params:
* mat - mat4 to calculate inverse of
* dest - Optional, mat4 receiving inverse matrix. If not specified result is written to mat
*
* Returns:
* dest is specified, mat otherwise
*/
mat4.inverse = function (mat, dest) {
    if (!dest) { dest = mat; }

    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
    var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant (inlined to avoid double-caching)
    var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
    dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
    dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
    dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
    dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
    dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
    dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
    dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
    dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
    dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
    dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
    dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
    dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
    dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
    dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
    dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

    return dest;
};

/*
* mat4.toRotationMat
* Copies the upper 3x3 elements of a mat4 into another mat4
*
* Params:
* mat - mat4 containing values to copy
* dest - Optional, mat4 receiving copied values
*
* Returns:
* dest is specified, a new mat4 otherwise
*/
mat4.toRotationMat = function (mat, dest) {
    if (!dest) { dest = mat4.create(); }

    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[3];
    dest[4] = mat[4];
    dest[5] = mat[5];
    dest[6] = mat[6];
    dest[7] = mat[7];
    dest[8] = mat[8];
    dest[9] = mat[9];
    dest[10] = mat[10];
    dest[11] = mat[11];
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;

    return dest;
};

/*
* mat4.toMat3
* Copies the upper 3x3 elements of a mat4 into a mat3
*
* Params:
* mat - mat4 containing values to copy
* dest - Optional, mat3 receiving copied values
*
* Returns:
* dest is specified, a new mat3 otherwise
*/
mat4.toMat3 = function (mat, dest) {
    if (!dest) { dest = mat3.create(); }

    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[4];
    dest[4] = mat[5];
    dest[5] = mat[6];
    dest[6] = mat[8];
    dest[7] = mat[9];
    dest[8] = mat[10];

    return dest;
};

/*
* mat4.toInverseMat3
* Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
* The resulting matrix is useful for calculating transformed normals
*
* Params:
* mat - mat4 containing values to invert and copy
* dest - Optional, mat3 receiving values
*
* Returns:
* dest is specified, a new mat3 otherwise
*/
mat4.toInverseMat3 = function (mat, dest) {
    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10];

    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;

    var d = a00 * b01 + a01 * b11 + a02 * b21;
    if (!d) { return null; }
    var id = 1 / d;

    if (!dest) { dest = mat3.create(); }

    dest[0] = b01 * id;
    dest[1] = (-a22 * a01 + a02 * a21) * id;
    dest[2] = (a12 * a01 - a02 * a11) * id;
    dest[3] = b11 * id;
    dest[4] = (a22 * a00 - a02 * a20) * id;
    dest[5] = (-a12 * a00 + a02 * a10) * id;
    dest[6] = b21 * id;
    dest[7] = (-a21 * a00 + a01 * a20) * id;
    dest[8] = (a11 * a00 - a01 * a10) * id;

    return dest;
};

/*
* mat4.multiply
* Performs a matrix multiplication
*
* Params:
* mat - mat4, first operand
* mat2 - mat4, second operand
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.multiply = function (mat, mat2, dest) {
    if (!dest) { dest = mat }

    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
    var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

    var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
    var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
    var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
    var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];

    dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
    dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
    dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
    dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
    dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
    dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
    dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
    dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
    dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
    dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
    dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
    dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
    dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
    dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
    dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
    dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

    return dest;
};

/*
* mat4.multiplyVec3
* Transforms a vec3 with the given matrix
* 4th vector component is implicitly '1'
*
* Params:
* mat - mat4 to transform the vector with
* vec - vec3 to transform
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
mat4.multiplyVec3 = function (mat, vec, dest) {
    if (!dest) { dest = vec }

    var x = vec[0], y = vec[1], z = vec[2];

    dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
    dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
    dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

    return dest;
};

/*
* mat4.multiplyVec4
* Transforms a vec4 with the given matrix
*
* Params:
* mat - mat4 to transform the vector with
* vec - vec4 to transform
* dest - Optional, vec4 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
mat4.multiplyVec4 = function (mat, vec, dest) {
    if (!dest) { dest = vec }

    var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

    dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
    dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
    dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
    dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

    return dest;
};

/*
* mat4.translate
* Translates a matrix by the given vector
*
* Params:
* mat - mat4 to translate
* vec - vec3 specifying the translation
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.translate = function (mat, vec, dest) {
    var x = vec[0], y = vec[1], z = vec[2];

    if (!dest || mat == dest) {
        mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
        mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
        return mat;
    }

    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];

    dest[0] = a00;
    dest[1] = a01;
    dest[2] = a02;
    dest[3] = a03;
    dest[4] = a10;
    dest[5] = a11;
    dest[6] = a12;
    dest[7] = a13;
    dest[8] = a20;
    dest[9] = a21;
    dest[10] = a22;
    dest[11] = a23;

    dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
    dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
    dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
    dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
    return dest;
};

/*
* mat4.scale
* Scales a matrix by the given vector
*
* Params:
* mat - mat4 to scale
* vec - vec3 specifying the scale for each axis
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.scale = function (mat, vec, dest) {
    var x = vec[0], y = vec[1], z = vec[2];

    if (!dest || mat == dest) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        return mat;
    }

    dest[0] = mat[0] * x;
    dest[1] = mat[1] * x;
    dest[2] = mat[2] * x;
    dest[3] = mat[3] * x;
    dest[4] = mat[4] * y;
    dest[5] = mat[5] * y;
    dest[6] = mat[6] * y;
    dest[7] = mat[7] * y;
    dest[8] = mat[8] * z;
    dest[9] = mat[9] * z;
    dest[10] = mat[10] * z;
    dest[11] = mat[11] * z;
    dest[12] = mat[12];
    dest[13] = mat[13];
    dest[14] = mat[14];
    dest[15] = mat[15];
    return dest;
};

/*
* mat4.rotate
* Rotates a matrix by the given angle around the specified axis
* If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
*
* Params:
* mat - mat4 to rotate
* angle - angle (in radians) to rotate
* axis - vec3 representing the axis to rotate around 
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.rotate = function (mat, angle, axis, dest) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    if (!len) { return null; }
    if (len != 1) {
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
    }

    var s = Math.sin(angle);
    var c = Math.cos(angle);
    var t = 1 - c;

    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];

    // Construct the elements of the rotation matrix
    var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s;
    var b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s;
    var b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;

    if (!dest) {
        dest = mat
    } else if (mat != dest) { // If the source and destination differ, copy the unchanged last row
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
    }

    // Perform rotation-specific matrix multiplication
    dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
    dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
    dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
    dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

    dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
    dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
    dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
    dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

    dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
    dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
    dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
    dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return dest;
};

/*
* mat4.rotateX
* Rotates a matrix by the given angle around the X axis
*
* Params:
* mat - mat4 to rotate
* angle - angle (in radians) to rotate
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.rotateX = function (mat, angle, dest) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);

    // Cache the matrix values (makes for huge speed increases!)
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];

    if (!dest) {
        dest = mat
    } else if (mat != dest) { // If the source and destination differ, copy the unchanged rows
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];

        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
    }

    // Perform axis-specific matrix multiplication
    dest[4] = a10 * c + a20 * s;
    dest[5] = a11 * c + a21 * s;
    dest[6] = a12 * c + a22 * s;
    dest[7] = a13 * c + a23 * s;

    dest[8] = a10 * -s + a20 * c;
    dest[9] = a11 * -s + a21 * c;
    dest[10] = a12 * -s + a22 * c;
    dest[11] = a13 * -s + a23 * c;
    return dest;
};

/*
* mat4.rotateY
* Rotates a matrix by the given angle around the Y axis
*
* Params:
* mat - mat4 to rotate
* angle - angle (in radians) to rotate
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.rotateY = function (mat, angle, dest) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);

    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];

    if (!dest) {
        dest = mat
    } else if (mat != dest) { // If the source and destination differ, copy the unchanged rows
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];

        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
    }

    // Perform axis-specific matrix multiplication
    dest[0] = a00 * c + a20 * -s;
    dest[1] = a01 * c + a21 * -s;
    dest[2] = a02 * c + a22 * -s;
    dest[3] = a03 * c + a23 * -s;

    dest[8] = a00 * s + a20 * c;
    dest[9] = a01 * s + a21 * c;
    dest[10] = a02 * s + a22 * c;
    dest[11] = a03 * s + a23 * c;
    return dest;
};

/*
* mat4.rotateZ
* Rotates a matrix by the given angle around the Z axis
*
* Params:
* mat - mat4 to rotate
* angle - angle (in radians) to rotate
* dest - Optional, mat4 receiving operation result. If not specified result is written to mat
*
* Returns:
* dest if specified, mat otherwise
*/
mat4.rotateZ = function (mat, angle, dest) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);

    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
    var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];

    if (!dest) {
        dest = mat
    } else if (mat != dest) { // If the source and destination differ, copy the unchanged last row
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];

        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
    }

    // Perform axis-specific matrix multiplication
    dest[0] = a00 * c + a10 * s;
    dest[1] = a01 * c + a11 * s;
    dest[2] = a02 * c + a12 * s;
    dest[3] = a03 * c + a13 * s;

    dest[4] = a00 * -s + a10 * c;
    dest[5] = a01 * -s + a11 * c;
    dest[6] = a02 * -s + a12 * c;
    dest[7] = a03 * -s + a13 * c;

    return dest;
};

/*
* mat4.frustum
* Generates a frustum matrix with the given bounds
*
* Params:
* left, right - scalar, left and right bounds of the frustum
* bottom, top - scalar, bottom and top bounds of the frustum
* near, far - scalar, near and far bounds of the frustum
* dest - Optional, mat4 frustum matrix will be written into
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
mat4.frustum = function (left, right, bottom, top, near, far, dest) {
    if (!dest) { dest = mat4.create(); }
    var rl = (right - left);
    var tb = (top - bottom);
    var fn = (far - near);
    dest[0] = (near * 2) / rl;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = (near * 2) / tb;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = (right + left) / rl;
    dest[9] = (top + bottom) / tb;
    dest[10] = -(far + near) / fn;
    dest[11] = -1;
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = -(far * near * 2) / fn;
    dest[15] = 0;
    return dest;
};

/*
* mat4.perspective
* Generates a perspective projection matrix with the given bounds
*
* Params:
* fovy - scalar, vertical field of view
* aspect - scalar, aspect ratio. typically viewport width/height
* near, far - scalar, near and far bounds of the frustum
* dest - Optional, mat4 frustum matrix will be written into
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
mat4.perspective = function (fovy, aspect, near, far, dest) {
    var top = near * Math.tan(fovy * Math.PI / 360.0);
    var right = top * aspect;
    return mat4.frustum(-right, right, -top, top, near, far, dest);
};

/*
* mat4.ortho
* Generates a orthogonal projection matrix with the given bounds
*
* Params:
* left, right - scalar, left and right bounds of the frustum
* bottom, top - scalar, bottom and top bounds of the frustum
* near, far - scalar, near and far bounds of the frustum
* dest - Optional, mat4 frustum matrix will be written into
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
mat4.ortho = function (left, right, bottom, top, near, far, dest) {
    if (!dest) { dest = mat4.create(); }
    var rl = (right - left);
    var tb = (top - bottom);
    var fn = (far - near);
    dest[0] = 2 / rl;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = 2 / tb;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = 0;
    dest[9] = 0;
    dest[10] = -2 / fn;
    dest[11] = 0;
    dest[12] = -(left + right) / rl;
    dest[13] = -(top + bottom) / tb;
    dest[14] = -(far + near) / fn;
    dest[15] = 1;
    return dest;
};

/*
* mat4.ortho
* Generates a look-at matrix with the given eye position, focal point, and up axis
*
* Params:
* eye - vec3, position of the viewer
* center - vec3, point the viewer is looking at
* up - vec3 pointing "up"
* dest - Optional, mat4 frustum matrix will be written into
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
mat4.lookAt = function (eye, center, up, dest) {
    if (!dest) { dest = mat4.create(); }

    var eyex = eye[0],
                eyey = eye[1],
                eyez = eye[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                centerx = center[0],
                centery = center[1],
                centerz = center[2];

    if (eyex == centerx && eyey == centery && eyez == centerz) {
        return mat4.identity(dest);
    }

    var z0, z1, z2, x0, x1, x2, y0, y1, y2, len;

    //vec3.direction(eye, center, z);
    z0 = eyex - center[0];
    z1 = eyey - center[1];
    z2 = eyez - center[2];

    // normalize (no check needed for 0 because of early return)
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    //vec3.normalize(vec3.cross(up, z, x));
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    };

    //vec3.normalize(vec3.cross(z, x, y));
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    dest[0] = x0;
    dest[1] = y0;
    dest[2] = z0;
    dest[3] = 0;
    dest[4] = x1;
    dest[5] = y1;
    dest[6] = z1;
    dest[7] = 0;
    dest[8] = x2;
    dest[9] = y2;
    dest[10] = z2;
    dest[11] = 0;
    dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    dest[15] = 1;

    return dest;
};

/*
* mat4.str
* Returns a string representation of a mat4
*
* Params:
* mat - mat4 to represent as a string
*
* Returns:
* string representation of mat
*/
mat4.str = function (mat) {
    return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
                ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
                ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
                ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
};

/*
* quat4 - Quaternions 
*/
quat4 = {};

/*
* quat4.create
* Creates a new instance of a quat4 using the default array type
* Any javascript array containing at least 4 numeric elements can serve as a quat4
*
* Params:
* quat - Optional, quat4 containing values to initialize with
*
* Returns:
* New quat4
*/
quat4.create = function (quat) {
    var dest = new glMatrixArrayType(4);

    if (quat) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];
    }

    return dest;
};

/*
* quat4.set
* Copies the values of one quat4 to another
*
* Params:
* quat - quat4 containing values to copy
* dest - quat4 receiving copied values
*
* Returns:
* dest
*/
quat4.set = function (quat, dest) {
    dest[0] = quat[0];
    dest[1] = quat[1];
    dest[2] = quat[2];
    dest[3] = quat[3];

    return dest;
};

/*
* quat4.calculateW
* Calculates the W component of a quat4 from the X, Y, and Z components.
* Assumes that quaternion is 1 unit in length. 
* Any existing W component will be ignored. 
*
* Params:
* quat - quat4 to calculate W component of
* dest - Optional, quat4 receiving calculated values. If not specified result is written to quat
*
* Returns:
* dest if specified, quat otherwise
*/
quat4.calculateW = function (quat, dest) {
    var x = quat[0], y = quat[1], z = quat[2];

    if (!dest || quat == dest) {
        quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return quat;
    }
    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
    dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return dest;
}

/*
* quat4.inverse
* Calculates the inverse of a quat4
*
* Params:
* quat - quat4 to calculate inverse of
* dest - Optional, quat4 receiving inverse values. If not specified result is written to quat
*
* Returns:
* dest if specified, quat otherwise
*/
quat4.inverse = function (quat, dest) {
    if (!dest || quat == dest) {
        quat[0] *= -1;
        quat[1] *= -1;
        quat[2] *= -1;
        return quat;
    }
    dest[0] = -quat[0];
    dest[1] = -quat[1];
    dest[2] = -quat[2];
    dest[3] = quat[3];
    return dest;
}

/*
* quat4.length
* Calculates the length of a quat4
*
* Params:
* quat - quat4 to calculate length of
*
* Returns:
* Length of quat
*/
quat4.length = function (quat) {
    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}

/*
* quat4.normalize
* Generates a unit quaternion of the same direction as the provided quat4
* If quaternion length is 0, returns [0, 0, 0, 0]
*
* Params:
* quat - quat4 to normalize
* dest - Optional, quat4 receiving operation result. If not specified result is written to quat
*
* Returns:
* dest if specified, quat otherwise
*/
quat4.normalize = function (quat, dest) {
    if (!dest) { dest = quat; }

    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
    var len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len == 0) {
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        return dest;
    }
    len = 1 / len;
    dest[0] = x * len;
    dest[1] = y * len;
    dest[2] = z * len;
    dest[3] = w * len;

    return dest;
}

/*
* quat4.multiply
* Performs a quaternion multiplication
*
* Params:
* quat - quat4, first operand
* quat2 - quat4, second operand
* dest - Optional, quat4 receiving operation result. If not specified result is written to quat
*
* Returns:
* dest if specified, quat otherwise
*/
quat4.multiply = function (quat, quat2, dest) {
    if (!dest) { dest = quat; }

    var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3];
    var qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

    dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    return dest;
}

/*
* quat4.multiplyVec3
* Transforms a vec3 with the given quaternion
*
* Params:
* quat - quat4 to transform the vector with
* vec - vec3 to transform
* dest - Optional, vec3 receiving operation result. If not specified result is written to vec
*
* Returns:
* dest if specified, vec otherwise
*/
quat4.multiplyVec3 = function (quat, vec, dest) {
    if (!dest) { dest = vec; }

    var x = vec[0], y = vec[1], z = vec[2];
    var qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3];

    // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return dest;
}

/*
* quat4.toMat3
* Calculates a 3x3 matrix from the given quat4
*
* Params:
* quat - quat4 to create matrix from
* dest - Optional, mat3 receiving operation result
*
* Returns:
* dest if specified, a new mat3 otherwise
*/
quat4.toMat3 = function (quat, dest) {
    if (!dest) { dest = mat3.create(); }

    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];

    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;

    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;

    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;

    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;

    dest[0] = 1 - (yy + zz);
    dest[1] = xy - wz;
    dest[2] = xz + wy;

    dest[3] = xy + wz;
    dest[4] = 1 - (xx + zz);
    dest[5] = yz - wx;

    dest[6] = xz - wy;
    dest[7] = yz + wx;
    dest[8] = 1 - (xx + yy);

    return dest;
}

/*
* quat4.toMat4
* Calculates a 4x4 matrix from the given quat4
*
* Params:
* quat - quat4 to create matrix from
* dest - Optional, mat4 receiving operation result
*
* Returns:
* dest if specified, a new mat4 otherwise
*/
quat4.toMat4 = function (quat, dest) {
    if (!dest) { dest = mat4.create(); }

    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];

    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;

    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;

    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;

    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;

    dest[0] = 1 - (yy + zz);
    dest[1] = xy - wz;
    dest[2] = xz + wy;
    dest[3] = 0;

    dest[4] = xy + wz;
    dest[5] = 1 - (xx + zz);
    dest[6] = yz - wx;
    dest[7] = 0;

    dest[8] = xz - wy;
    dest[9] = yz + wx;
    dest[10] = 1 - (xx + yy);
    dest[11] = 0;

    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;

    return dest;
}

/*
* quat4.slerp
* Performs a spherical linear interpolation between two quat4
*
* Params:
* quat - quat4, first quaternion
* quat2 - quat4, second quaternion
* slerp - interpolation amount between the two inputs
* dest - Optional, quat4 receiving operation result. If not specified result is written to quat
*
* Returns:
* dest if specified, quat otherwise
*/
quat4.slerp = function (quat, quat2, slerp, dest) {
    if (!dest) { dest = quat; }

    var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3];

    if (Math.abs(cosHalfTheta) >= 1.0) {
        if (dest != quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        }
        return dest;
    }

    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    if (Math.abs(sinHalfTheta) < 0.001) {
        dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
        dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
        dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
        dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
        return dest;
    }

    var ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
    var ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

    dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
    dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
    dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
    dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

    return dest;
}


/*
* quat4.str
* Returns a string representation of a quaternion
*
* Params:
* quat - quat4 to represent as a string
*
* Returns:
* string representation of quat
*/
quat4.str = function (quat) {
    return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
}
/*
* Copyright 2010, Google Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
*     * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following disclaimer
* in the documentation and/or other materials provided with the
* distribution.
*     * Neither the name of Google Inc. nor the names of its
* contributors may be used to endorse or promote products derived from
* this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/**
* @fileoverview This file contains functions every webgl program will need
* a version of one way or another.
*
* Instead of setting up a context manually it is recommended to
* use. This will check for success or failure. On failure it
* will attempt to present an approriate message to the user.
*
*       gl = WebGLUtils.setupWebGL(canvas);
*
* For animated WebGL apps use of setTimeout or setInterval are
* discouraged. It is recommended you structure your rendering
* loop like this.
*
*       function render() {
*         window.requestAnimFrame(render, canvas);
*
*         // do rendering
*         ...
*       }
*       render();
*
* This will call your rendering function up to the refresh rate
* of your display but will stop rendering if your app is not
* visible.
*/

WebGLUtils = function () {

    /**
    * Creates the HTLM for a failure message
    * @param {string} canvasContainerId id of container of th
    *        canvas.
    * @return {string} The html.
    */
    var makeFailHTML = function (msg) {
        return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + msg + '</div>' +
    '</div>' +
    '</td></tr></table>';
    };

    /**
    * Mesasge for getting a webgl browser
    * @type {string}
    */
    var GET_A_WEBGL_BROWSER = '' +
  'This page requires a browser that supports WebGL.<br/>' +
  '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

    /**
    * Mesasge for need better hardware
    * @type {string}
    */
    var OTHER_PROBLEM = '' +
  "It doesn't appear your computer can support WebGL.<br/>" +
  '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

    /**
    * Creates a webgl context. If creation fails it will
    * change the contents of the container of the <canvas>
    * tag to an error message with the correct links for WebGL.
    * @param {Element} canvas. The canvas element to create a
    *     context from.
    * @param {WebGLContextCreationAttirbutes} opt_attribs Any
    *     creation attributes you want to pass in.
    * @return {WebGLRenderingContext} The created context.
    */
    var setupWebGL = function (canvas, opt_attribs) {
        function showLink(str) {
            var container = canvas.parentNode;
            if (container) {
                container.innerHTML = makeFailHTML(str);
            }
        };

        if (!window.WebGLRenderingContext) {
            showLink(GET_A_WEBGL_BROWSER);
            return null;
        }

        var context = create3DContext(canvas, opt_attribs);
        if (!context) {
            showLink(OTHER_PROBLEM);
        }
        return context;
    };

    /**
    * Creates a webgl context.
    * @param {!Canvas} canvas The canvas tag to get context
    *     from. If one is not passed in one will be created.
    * @return {!WebGLContext} The created context.
    */
    var create3DContext = function (canvas, opt_attribs) {
        var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        var context = null;
        for (var ii = 0; ii < names.length; ++ii) {
            try {
                context = canvas.getContext(names[ii], opt_attribs);
            } catch (e) { }
            if (context) {
                break;
            }
        }
        return context;
    }

    return {
        create3DContext: create3DContext,
        setupWebGL: setupWebGL
    };
} ();

/**
* Provides requestAnimationFrame in a cross browser way.
*/
window.requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function (/* function FrameRequestCallback */callback, /* DOMElement Element */element) {
             window.setTimeout(callback, 1000 / 60);
         };
})();
/*
GlowScript was begun in the summer of 2011 by David Scherer and Bruce Sherwood
to implement an API for JavaScript/WebGL based on that of VPython (vpython.org).
 
Help from the following people in getting started is gratefully acknowledged:
Greg Sonnenfeld, Owen Densmore, and Nicolas Garcia Belmonte.
 
Feel free to use or modify this material for any purpose, but please retain this notice.
*/

(function vectorLibraryWrappers() {
	"use strict";

	function dot(A, B) {
		return A.dot(B)
	}
	function cross(A, B) {
		return A.cross(B)
	}
	function proj(A, B) {
		return A.proj(B);
	}
	function comp(A, B) {
		return A.comp(B);
	}
	function mag(A) {
		return A.mag();
	}
	function mag2(A) {
		return A.mag2();
	}
	function norm(A) {
		return A.norm();
	}

	var exports = {
		dot: dot,
		cross: cross,
		proj: proj,
		comp: comp,
		mag: mag,
		mag2: mag2,
		norm: norm
	}

	// For now, just dump all exports into the global scope
	for(var id in exports)
		window[id] = exports[id]
})();

(function () {
	"use strict";

	var scene = new sceneParameters // foreground, background, etc.
	scene.__labels = {label_objects:[], __changed:false }
	scene.__last_forward = null
	scene.__last_range = null
	
	scene.__extent = {
		xmin: null,
		ymin: null,
		zmin: null,
		xmax: null,
		ymax: null,
		zmax: null,
		zx_camera: 0,
		zy_camera: 0,
		last_zx_camera: -1,
		last_zy_camera: -1,
		find_autocenter: false
	}
	
	// Establish defaults
	scene.__center = vec(0,0,0)
	scene.__up = vec(0,1,0)
	scene.__fov = 60*Math.PI/180
	scene.__range = 10 // this also sets scale
	scene.__autoscale = true // override range setting, which sets autoscale to false
	scene.__forward = vec(0,0,-1)

	var shiftKey = 16
	var ctrlKey = 17
	var altKey = 18
	// Mac cmd key is 91 on MacBook Pro but apparently may be different on other Macs.

	// Simplified handling for canvas-related mouse events, for the script
	// We don't have to support every possible advanced feature (e.g. extra buttons), because the script can go directly to jquery
	// The objective is just to make the very simplest mouse interactions with the canvas very easy
	// Possibly we shouldn't even go this far.
	// SOMEDAY: Picking, projection, etc
	var on = {
		click: null,
		mousedown: null,
		mouseup: null,
		mousemove: null,
		redraw: null
	}
	var waitfor = {}
	for(var e in on) {
		(function(e) {
			waitfor[e] = function(cb) { 
				if (cb === undefined) throw new Error("waitfor." + e + " without required (wait) parameter");
				on[e] = function(x) { on[e] = null; cb.apply(null, arguments) }
			}
		})(e)
	}

	function declareSceneAttr( name, defaultValue ) {
		var internal_name = '__' + name

		Object.defineProperty(sceneParameters.prototype, internal_name, { enumerable: false, writable: true, value: defaultValue })
		Object.defineProperty(sceneParameters.prototype, name, {
			enumerable: true,
			get: 
				function() { return this[internal_name] },
			set: 
				function(value) { 
					if (internal_name == '__center') {
						scene.camera.pos = scene.camera.pos.add(value.sub(scene.__center))
					} else if (internal_name == '__forward') {
						var dist = scene.camera.pos.sub(scene.__center).mag()
						scene.camera.pos = scene.__center.sub(value.norm().multiply(dist))
					} else if (internal_name == '__autoscale') {
						// If changing from autoscale true -> false, make sure scene has been autoscaled:
						if (scene.__autoscale && !value) compute_autoscale()
					} else if (internal_name == '__autocenter') {
						// If changing from autocenter true -> false, make sure scene has been autocentered:
						if (scene.__autocenter && !value) compute_autocenter()
					}
					this[internal_name] = value }
			});
	}

	function declareSceneAttrScaling( name, defaultValue ) {
		var internal_name = '__' + name

		Object.defineProperty(sceneParameters.prototype, internal_name, { enumerable: false, writable: true, value: defaultValue })
		Object.defineProperty(sceneParameters.prototype, name, {
			enumerable: true,
			get: 
				function() { return this[internal_name] },
			set: 
				function(value) { 
					this[internal_name] = value 
					if (internal_name == '__range') {
						this.__scale = 1/value
					} else if (internal_name == '__scale') {
						this.__range = 1/value
					}
					if (internal_name == '__range' || internal_name == '__scale') {
						var dist = this.__range/Math.tan(scene.__fov/2)
						scene.camera.pos = scene.__center.sub(scene.__forward.norm().multiply(dist))
					}
					this.autoscale = false // if range or scale is set, turn off autoscaling
				}
			});
	}

	function declareReadOnlySceneAttr( name, defaultValue ) {
		var internal_name = '__' + name

		Object.defineProperty(sceneParameters.prototype, internal_name, { enumerable: false, writable: true, value: defaultValue })
		Object.defineProperty(sceneParameters.prototype, name, {
			enumerable: true,
			get: 
				function() { return this[internal_name] },
			set: 
				function(value) { throw new Error("scene."+name+" is read-only") }
			});
	}

	function sceneParameters () { 
		this.__visiblePrimitives = {}
	}

	Object.defineProperty(sceneParameters.prototype, 'objects', {
		enumerable: true,
		get:
			function () { 
				var all = []
				for(var id in this.__visiblePrimitives)
					all.push(this.__visiblePrimitives[id])
				return all
			}
	})

	declareReadOnlySceneAttr( 'width', 500 )
	declareReadOnlySceneAttr( 'height', 500 )
	declareSceneAttr( 'foreground', vec(1,1,1) )
	declareSceneAttr( 'background', vec(0,0,0) )
	//declareReadOnlySceneAttr( 'cursor', {visible: true} ) // not implemented yet
	declareSceneAttr( 'userzoom', true )
	declareSceneAttr( 'userspin', true )

	declareSceneAttr( 'ambient', vec(0.2,0.2,0.2) )
	declareSceneAttr( 'lights', [
		{direction: vec(0.21821789, 0.4364357, 0.8728715), color: vec(.8,.8,.8) } ,
		{direction: vec(-0.872872, -0.218218, -0.436436), color: vec(.3,.3,.3) } ,
		])

	//declareSceneAttr( 'stereo', null ) // not implemented yet
	declareSceneAttr( 'autocenter', false )
	declareSceneAttr( 'autoscale', true )

	declareSceneAttr( 'center', vec(0,0,0) )
	declareSceneAttr( 'forward', vec(0,0,-1) )
	declareSceneAttr( 'up', vec(0,1,0))
	declareSceneAttr( 'fov', 60 )
	declareSceneAttrScaling( 'range', 10 )
	declareSceneAttrScaling( 'scale', 0.1 )
	
	declareReadOnlySceneAttr( 'camera', {
		pos: vec(0,0,scene.__range/Math.tan(scene.__fov/2))
	} )

	declareReadOnlySceneAttr( 'mouse', { // not quite right; pos etc. are not read-only
		// Only pos, ray, alt, ctrl, shift have been implemented; some of this is now irrelevant
		//events:   0,
		//getevent: function() {},
		pos:	  null,
		//button:	  null,
		//clicked:  null,
		//getclick: function() {},
		//press:	  null,
		//click:	  null,
		//drag:	  null,
		//drop:	  null,
		//release:  null,
		//pick:	  null,
		//pickpos:  null,
		ray:	  null,
		project:  function(normal, param) {
				if (normal === undefined) throw new Error("scene.mouse.project() must specify a normal and a point or a distance")
				if (param === undefined) param = scene.center
				if (param.x !== undefined) {
					var dist = normal.dot(param)
				} else {
					var dist = param
				} 
				var ndc = normal.dot(scene.__camera.pos) - dist
				var ndr = normal.dot(scene.__mouse.ray)
				if (ndr == 0) return null
				var t = -ndc / ndr
				return scene.__camera.pos.add(scene.__mouse.ray.multiply(t))
			},
		alt:	  false, // true if ALT key is down
		ctrl:	  false, // true if CTRL key is down
		shift:	  false  // true if SHIFT key is down
	} )

	var mouse = {
		rotating: false,
		zooming: false,
		leftButton: false, 
		rightButton: false,
		update: function (ev, canvas) {
			var factor = 2*scene.__range/scene.__height // real coord per pixel
			// mx,my in plane perpendicular to scene.forward:
			var mx =  (ev.pageX-canvas.offsetLeft-scene.__width/2) * factor 
			var my = -(ev.pageY-canvas.offsetTop-scene.__height/2) * factor
			var xaxis = scene.__forward.norm().cross(scene.__up).norm()
			var yaxis = xaxis.cross(scene.__forward.norm()) // this is normalized by construction
			this.pos = scene.__mouse.pos = scene.__center.add(xaxis.multiply(mx).add(yaxis.multiply(my)))
			scene.__mouse.ray = scene.__mouse.pos.sub(scene.camera.pos).norm()
		}
	}

	function scriptMouseEvents(canvas) {
		$(canvas).click(function(ev) {
			mouse.update(ev, canvas)
			if (ev.which == 1 && on.click) on.click()
		})
		$(canvas).mousedown(function (ev) {
			if (ev.which == 1 && !mouse.rotating && !mouse.zooming) {
				mouse.leftButton = true
				mouse.update(ev, canvas);
				if (on.mousedown) on.mousedown()
				ev.preventDefault()
				ev.stopPropagation()
				return false;
			}
		})
		$(document).mousemove(function (ev) {
			mouse.update(ev, canvas)
			if (ev.which == 1 && !mouse.rotating && !mouse.zooming && on.mousemove) {
				on.mousemove()
			}
		})
		$(document).mouseup(function (ev) {
			if (ev.which == 1 && !mouse.rotating && !mouse.zooming) mouse.leftButton = false
			mouse.update(ev, canvas);
			if (ev.which == 1 && on.mouseup) {
				on.mouseup()
			}
		})
	}

	function cameraControl(canvas, camera) {
		// Using jquery for event handling here hopefully hides differences between browsers!
		var contextMenuDisabled = false
		var lastX=null, lastY=null
		var angleX=null, angleY=null
	
		var zoom = function(ev, delta) {
			var old_distance = scene.camera.pos.sub(scene.__center).mag()
			var new_distance = old_distance*Math.exp(-delta * .05)
			scene.__range *= new_distance/old_distance
			scene.__scale = 1/scene.__range
			scene.__autoscale = false
			scene.camera.pos = scene.__center.add(scene.camera.pos.sub(scene.__center).multiply(new_distance/old_distance))
		}

		$(document).bind("contextmenu", function (e) {
			return !contextMenuDisabled;
		})
		$(canvas).mousewheel(function (ev, delta) { // ev.which is 0 during mousewheel move
			if (scene.__userzoom) zoom(ev, delta)
			return false;
		})
		$(document).keydown(function (ev) {
			switch (ev.which) {
				case shiftKey:
					scene.__mouse.shift = true
					break
				case altKey:
					scene.__mouse.alt = true
					break
				case ctrlKey:
					scene.__mouse.ctrl = true
					break
			}
		})
		$(document).keyup(function (ev) {
			switch (ev.which) {
				case shiftKey:
					scene.__mouse.shift = false
					break
				case altKey:
					scene.__mouse.alt = false
					break
				case ctrlKey:
					scene.__mouse.ctrl = false
					break
			}
		})
		$(canvas).mousedown(function (ev) {
			// This basic mousedown event happens before the user script mousedown event
			// ev.which is 1 for left button, 2 for mousewheel, 3 for right button
			if (ev.which == 1) mouse.leftButton = true
			if (ev.which == 3) mouse.rightButton = true
			mouse.rotating = (scene.__userspin && (ev.which == 3 || (ev.which == 1 && scene.__mouse.ctrl && !scene.__mouse.alt)))
			mouse.zooming = (scene.__userzoom && (ev.which == 2 || (ev.which == 1 && scene.__mouse.alt && !scene.__mouse.ctrl)
					|| (mouse.leftButton && mouse.rightButton)))
			if (mouse.rotating || mouse.zooming) {
				contextMenuDisabled = true
				lastX = ev.pageX; lastY = ev.pageY
				ev.preventDefault()
				ev.stopPropagation()
				return false
			}
		})
		// Ideally we should bind and unbind this as rotating and zooming change
		$(document).mousemove( function (ev) {
			if (mouse.zooming) {
				var dy = lastY - ev.pageY
				lastY = ev.pageY
				zoom(ev, 0.1*dy)
			} else if (mouse.rotating) {
				var dx = ev.pageX - lastX; var dy = ev.pageY - lastY
				lastX = ev.pageX; lastY = ev.pageY
				angleX += dx * .01
				angleY += dy * .01; 
				if (angleY < -1.4) angleY = -1.4; 
				if (angleY > 1.4) angleY = 1.4;
				var distance = scene.__range/Math.tan(scene.__fov/2)
				scene.__forward = scene.__forward.rotate(-.01*dx, scene.__up)
				var max_vertical_angle = scene.__up.diff_angle(scene.__forward.multiply(-1))
				var vertical_angle = .01*dy
				if (!(vertical_angle >= max_vertical_angle || vertical_angle <= (max_vertical_angle - Math.PI))) {
						// Over the top (or under the bottom) rotation
					scene.__forward = scene.__forward.rotate(-vertical_angle, scene.__forward.cross(scene.__up))
				}
				scene.camera.pos = scene.__center.sub(scene.__forward.norm().multiply(distance))
			}
		})
		$(document).mouseup(function (ev) {
			if (ev.which == 1) mouse.leftButton = false
			if (ev.which == 3) mouse.rightButton = false
			if (mouse.rotating || mouse.zooming) {
				mouse.rotating = mouse.zooming = false
				setTimeout(function() { contextMenuDisabled = false }, 0)
				return false
			}
		})
	}

	// Mesh() represents a mesh of triangles
	function Mesh() {
		this.vertices = []
		this.normals = []
		this.indices = []
	}
	Mesh.prototype.merge = function merge(otherMesh) {
		var offset = this.vertices.length/3
		for(var j=0; j<otherMesh.vertices.length; j++)
			this.vertices.push(otherMesh.vertices[j])
		for(var j=0; j<otherMesh.normals.length; j++)
			this.normals.push(otherMesh.normals[j])
		for(var j=0; j<otherMesh.indices.length; j++)
			this.indices.push(offset + otherMesh.indices[j])
	}
	Mesh.prototype.transformed = function transformed(matrix) {
		var normalTrans = mat3.toMat4( mat3.transpose(mat4.toInverseMat3(matrix)) )
		var out = new Mesh()
		out.indices = this.indices
		for (var i = 0; i < this.vertices.length; i += 3) {
			var v = [this.vertices[i], this.vertices[i + 1], this.vertices[i + 2]]
			var n = [this.normals[i], this.normals[i + 1], this.normals[i + 2], 0]
			mat4.multiplyVec3(matrix, v)
			mat4.multiplyVec4(normalTrans, n)
			out.vertices.push(v[0], v[1], v[2])
			out.normals.push(n[0], n[1], n[2])
		}
		return out
	}
	
	var cot_hfov = 1/Math.tan(scene.__fov/2)
	
	function compute_autocenter() {
		scene.__extent.find_autocenter = true
		scene.__extent.xmin = null
		scene.__extent.ymin = null
		scene.__extent.zmin = null
		scene.__extent.xmax = null
		scene.__extent.ymax = null
		scene.__extent.zmax = null
		scene.__extent.zx_camera = 0
		scene.__extent.zy_camera = 0
		var check = false
		var obj
		for (var id in scene.__visiblePrimitives) {
			obj = scene.__visiblePrimitives[id]
			check = true
			if (scene.__changed[obj.__id]) obj.__get_extent()
			else {
				scene.__extent.xmin = Math.min(scene.__extent.xmin, obj.__xmin)
				scene.__extent.ymin = Math.min(scene.__extent.ymin, obj.__ymin)
				scene.__extent.zmin = Math.min(scene.__extent.zmin, obj.__zmin)
				scene.__extent.xmax = Math.max(scene.__extent.xmax, obj.__xmax)
				scene.__extent.ymax = Math.max(scene.__extent.ymax, obj.__ymax)
				scene.__extent.zmax = Math.max(scene.__extent.zmax, obj.__zmax)
			}
		}
		if (check) {
			scene.__center = vec((scene.__extent.xmin+scene.__extent.xmax)/2, (scene.__extent.ymin+scene.__extent.ymax)/2, (scene.__extent.zmin+scene.__extent.zmax)/2)
		}
		scene.__extent.find_autocenter = false
	}
	
	function compute_autoscale() {
		scene.__extent.zx_camera = 0
		scene.__extent.zy_camera = 0
		cot_hfov = 1/Math.tan(scene.__fov/2) // re-establish cot_hfov
		var check = false
		var obj
		for (var id in scene.__visiblePrimitives) {
			obj = scene.__visiblePrimitives[id]
			check = true
			if (scene.__changed[obj.__id] || obj.__zx_camera == null || obj.__zy_camera == null) {
				obj.__get_extent()
				var xx = Math.max(Math.abs(obj.__xmin-scene.__center.x), Math.abs(obj.__xmax-scene.__center.x))
				var yy = Math.max(Math.abs(obj.__ymin-scene.__center.y), Math.abs(obj.__ymax-scene.__center.y))
				var zz = Math.max(Math.abs(obj.__zmin-scene.__center.z), Math.abs(obj.__zmax-scene.__center.z))
				obj.__zx_camera = xx*cot_hfov + zz
				obj.__zy_camera = yy*cot_hfov + zz
			}
			scene.__extent.zx_camera = Math.max(scene.__extent.zx_camera,obj.__zx_camera)
			scene.__extent.zy_camera = Math.max(scene.__extent.zy_camera,obj.__zy_camera)
		}
		if (check) {
			if (scene.__extent.zx_camera > scene.__extent.last_zx_camera || scene.__extent.zx_camera < scene.__extent.last_zx_camera/3 ||
				scene.__extent.zy_camera > scene.__extent.last_zy_camera || scene.__extent.zy_camera < scene.__extent.last_zy_camera/3) {
				var predicted_zy = scene.__extent.zx_camera*scene.height/scene.width
				if (predicted_zy > scene.__extent.zy_camera) {
					if (scene.width >= scene.height ) {
						scene.__range = 1.1*(scene.height/scene.width)*scene.__extent.zx_camera/cot_hfov
					} else {
						scene.__range = 1.1*scene.__extent.zx_camera/cot_hfov
					}
				}
				else {
					if (scene.width >= scene.height ) {
						scene.__range = 1.1*scene.__extent.zy_camera/cot_hfov
					} else {
						scene.__range = 1.1*(scene.width/scene.height)*scene.__extent.zy_camera/cot_hfov
					}
				}
				scene.camera.pos = scene.__center.sub(scene.__forward.norm().multiply(scene.__range*cot_hfov))
				scene.__extent.last_zx_camera = scene.__extent.zx_camera
				scene.__extent.last_zy_camera = scene.__extent.zy_camera
			}
		}
	} // End of machinery for autoscaling and autocentering

	function WebGLRenderer(canvas, overlay) {
		scene.overlay = overlay
		scene.overlay_context = overlay.getContext("2d")
		var renderer = this
		var gl = this.gl = WebGLUtils.setupWebGL(canvas)
		var models

		this.screenshot = function screenshot(callback) {
			var onf = on.redraw
			on.redraw = function(err, elapsed) {
			  on.redraw = onf
			  if (onf) onf(err, elapsed);
			  var image = new Image()
			  image.src = canvas.toDataURL()
			  callback( err, image )
			}
		}

		this.reset = function () {
			scene.__width = canvas.clientWidth
			scene.__height = canvas.clientHeight
	
			for (var t in models)
				models[t].id_object = {}
		}

		var camera = { target: vec3.create([0,0,0]), up: vec3.create([0,1,0]), fovy: 60, angleX: 0, angleY: 0, distance: 1 }
		cameraControl(overlay, camera) // was cameraControl(canvas, camera) before adding 2d canvas (called overlay)
		
		this.reset()

		function shaderProgram(fragSrc, vertSrc) {
			function makeShader(text, type) {
				var shader = gl.createShader(type)
				gl.shaderSource(shader, text)
				gl.compileShader(shader)
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert( gl.getShaderInfoLog(shader) )
					throw new Error("Shader compile error")
				}
				return shader
			}
			var fragmentShader = makeShader(fragSrc, gl.FRAGMENT_SHADER)
			var vertexShader = makeShader(vertSrc, gl.VERTEX_SHADER)
			var shaderProgram = gl.createProgram()
			gl.attachShader(shaderProgram, vertexShader)
			gl.attachShader(shaderProgram, fragmentShader)
			gl.linkProgram(shaderProgram)
			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert(gl.getProgramInfoLog(shaderProgram))
				throw new Error("Shader link error")
			}
			var uniforms = gl.getProgramParameter(shaderProgram, gl.ACTIVE_UNIFORMS)
			shaderProgram.uniforms = {}
			for (var i = 0; i < uniforms; i++) {
				var t = gl.getActiveUniform(shaderProgram, i)
				var name = t.name
				if (name.substring(name.length-3)=="[0]") name = name.substring(0, name.length-3)
				shaderProgram.uniforms[name] = gl.getUniformLocation(shaderProgram, name)
				//console.log(t.name, name)
			}
			var attributes = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES)
			shaderProgram.attributes = {}
			for (var i = 0; i < attributes; i++) {
				var t = gl.getActiveAttrib(shaderProgram, i)
				shaderProgram.attributes[t.name] = gl.getAttribLocation(shaderProgram, t.name)
			}

			return shaderProgram
		}

		function Model(mesh) {
			this.elementType = gl.TRIANGLES
			this.mesh = mesh
			this.vertices = new Float32Array(mesh.vertices)
			this.normals = new Float32Array(mesh.normals)
			this.indices = new Uint16Array(mesh.indices)
			this.indexCount = this.indices.length

			this.posBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW)

			this.normalBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, this.normals, gl.STATIC_DRAW)

			this.indexBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW)
		}

		// These get rendered with the "object" vertex program
		var object_models = {
			box: new Model(makeCube() ),                    // default box size is (1,1,1)
			pyramid: new Model(makePyramid() ),             // default pyramid size is (1,1,1)
			cylinder: new Model(makeCylinder(.5) ),         // default cylinder size is (1,1,1)
			cone: new Model(makeCone(.5) ),                 // default cone size is (1,1,1)
			sphere: new Model(makeSphere(.5,30) ),          // default sphere size is (1,1,1)
		};
		models = this.models = {
			curve: new Model(makeCurveSegment(1) ), // default curve_segment size is (1,1,1)
			}
		var compoundCount=0
		models.compound = function compoundModel(mesh) {
			var m = new Model(mesh)
			m.id_object = {}
			object_models[compoundCount++] = m  // Actually render the object(s) of this model
			return m
		}
		models.compound.Mesh = Mesh

		for(var id in object_models)
			models[id] = object_models[id];
		for(var id in models)
			window[id].prototype.__model = models[id]

		var program = shaderProgram( shaders.plastic_fragment, shaders.object_vertex )
		var curve_program = shaderProgram( shaders.plastic_fragment, shaders.curve_vertex )

		var fps = 0
		var renderMS = 0
		var lastFrame = new Date().getTime() * .001

		function render() {
			var startTime = new Date().getTime() * .001

			// Render at an appropriate frame rate (recommended over setInterval)
			window.requestAnimFrame(render, canvas)
			
			if (scene.__autocenter) compute_autocenter()
			if (scene.__autoscale) compute_autoscale()
			
			for(var id in scene.__changed) {
				scene.__changed[id].__update()
			}
			scene.__changed = {}
		
			camera.target = vec3.create([scene.__center.x, scene.__center.y, scene.__center.z])
			camera.up = vec3.create([scene.__up.x, scene.__up.y, scene.__up.z])
			camera.fovy = scene.__fov*180/Math.PI
			var xz_unit_vector = vec(scene.__forward.x,0,scene.__forward.z).norm()
			camera.angleX = Math.atan2(xz_unit_vector.x,-xz_unit_vector.z)
			camera.angleY = Math.PI/2 - Math.acos(-scene.__forward.norm().y)
			if (canvas.clientWidth >= canvas.clientHeight) camera.distance = scene.__range/Math.tan(scene.__fov/2)
			else camera.distance = scene.__range*(canvas.clientHeight / canvas.clientWidth)/Math.tan(scene.__fov/2)
			
			camera.pos = mat4.multiplyVec3(
				mat4.rotateX(mat4.rotateY(mat4.identity(mat4.create()), -camera.angleX), -camera.angleY),
				vec3.create([0,0,camera.distance]))
			camera.pos = vec3.create([scene.__center.x+camera.pos[0],
									  scene.__center.y+camera.pos[1],
									  scene.__center.z+camera.pos[2]])
			

			gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
			gl.clearColor(scene.__background.x, scene.__background.y, scene.__background.z, 1);
			gl.clearDepth(1);
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Compute a view and projection matrix from camera, z range, and the canvas aspect ratio
			camera.zNear = camera.distance / 100
			camera.zFar = camera.distance * 10
			var projMatrix = mat4.perspective( camera.fovy, canvas.clientWidth / canvas.clientHeight, camera.zNear, camera.zFar)
			var viewMatrix = mat4.lookAt(camera.pos, camera.target, camera.up)
			//mat4.multiply(projMatrix, viewMatrix, viewMatrix)

			// Transform lights into eye space
			var MAX_LIGHTS = 8
			var light_pos = new Float32Array( MAX_LIGHTS*4 )
			var light_color = new Float32Array( MAX_LIGHTS*3 )
			var light_count = Math.min(scene.lights.length, MAX_LIGHTS)
			for(var i=0; i<light_count; i++) {
				var light = scene.lights[i]
				if (light.direction === undefined)
					var lightVec4 = [ light.pos.x, light.pos.y, light.pos.z, 1 ]
				else
					var lightVec4 = [ light.direction.x, light.direction.y, light.direction.z, 0 ]
				light.transformed = lightVec4
				mat4.multiplyVec4(viewMatrix, lightVec4)
				for(var c=0; c<4; c++)
					light_pos[i*4+c] = lightVec4[c]
				light_color[i*3] = light.color.x
				light_color[i*3+1] = light.color.y
				light_color[i*3+2] = light.color.z
			}
			
			if (scene.__labels.label_objects.length > 0 && (scene.__labels.__changed ||
					!(scene.__forward.equal(scene.__last_forward) && (scene.__range == scene.__last_range)))) {
				scene.__labels.__changed = false
				var ctx = scene.overlay_context
				ctx.clearRect(0, 0, scene.__width, scene.__height)
				for (var i=0; i<scene.__labels.label_objects.length; i++) {
					var obj = scene.__labels.label_objects[i]
					if (!obj.visible) continue
					obj.__update(ctx, camera)
				}
			}

			function useProgram(program) {
				// This needs to happen once per program, before rendering objects with that program
				// These uniforms are common to all programs
				gl.useProgram(program)
				gl.enableVertexAttribArray(program.attributes.position);
				gl.enableVertexAttribArray(program.attributes.normal);
				gl.uniformMatrix4fv(program.uniforms.viewMatrix, false, viewMatrix)
				gl.uniformMatrix4fv(program.uniforms.projMatrix, false, projMatrix)
				gl.uniform1i(program.uniforms.light_count, light_count)
				gl.uniform4fv(program.uniforms.light_pos, light_pos)
				gl.uniform3fv(program.uniforms.light_color, light_color)
				gl.uniform1f(program.uniforms.shininess, 64.0)
			}

			useProgram(program)

			//console.log(light_count, light_pos, light_color, program.uniforms.light_count, program.uniforms.light_pos, program.uniforms.light_color)
			
			//console.log(object_models)
			for(var m in object_models) {  // TODO: Only models with any visible primitives
				var model = object_models[m]
				var objs = model.id_object

				// This needs to happen once per model, before rendering objects with that model
				gl.bindBuffer(gl.ARRAY_BUFFER, model.posBuffer)
				gl.vertexAttribPointer(program.attributes.position, 3, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer)
				gl.vertexAttribPointer(program.attributes.normal, 3, gl.FLOAT, false, 0, 0)
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer)

				for (var id in objs) {
					var prim = objs[id]
					// This stuff needs to happen for each individual object
					gl.uniform4fv(program.uniforms.objectData, prim)
					gl.drawElements(model.elementType, model.indexCount, gl.UNSIGNED_SHORT, 0)
				}
			}

			// Render all curve segments, using a special program
			useProgram(curve_program)
			
			var model = models.curve
			gl.bindBuffer(gl.ARRAY_BUFFER, model.posBuffer)
			gl.vertexAttribPointer(curve_program.attributes.position, 4, gl.FLOAT, false, 0, 0)
			gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer)
			gl.vertexAttribPointer(curve_program.attributes.normal, 3, gl.FLOAT, false, 0, 0)
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer)

			var objs = model.id_object
			for(var id in objs) {
				var prim = objs[id]
				gl.uniform4fv(curve_program.uniforms.segmentData, prim)
				gl.drawElements(model.elementType, model.indexCount, gl.UNSIGNED_SHORT, 0)
			}

			gl.flush()
			var t = new Date().getTime() * .001
			var elapsed = t - lastFrame
			lastFrame = t
			renderMS = renderMS * .95 + (t - startTime) * 1000 * .05

			fps = fps * .95 + (1.0 / (elapsed+.001)) * .05

			$("#fps").text(fps.toFixed(1) + " fps; " + renderMS.toFixed(1) + " ms render")
			//alert( gl.getError() )
			if (on.redraw) on.redraw(null, elapsed)
			graph_update()
			scene.__last_forward = scene.__forward
			scene.__last_range = scene.__range
		}
		this.reset()
		render()
	}

	scene.setCanvas = function( canvas, overlay ) {
		scene.renderer = new WebGLRenderer( canvas, overlay )
		scriptMouseEvents(overlay)
	}
	
	function makeCube() {
		var m = new Mesh()
		var s = 0.5; // from VPython; 1x1x1 cube
		m.vertices.push( 
			  +s, +s, +s,    +s, -s, +s,     +s, -s, -s,     +s, +s, -s,   // Right face
			  -s, +s, -s,    -s, -s, -s,     -s, -s, +s,     -s, +s, +s,   // Left face
			  -s, -s, +s,    -s, -s, -s,     +s, -s, -s,     +s, -s, +s,   // Bottom face
			  -s, +s, -s,    -s, +s, +s,     +s, +s, +s,     +s, +s, -s,   // Top face
			  +s, +s, +s,    -s, +s, +s,     -s, -s, +s,     +s, -s, +s,   // Front face
			  -s, -s, -s,    -s, +s, -s,     +s, +s, -s,     +s, -s, -s )  // Back face
		m.normals.push(
			  +1, 0, 0 ,  +1, 0, 0 ,  +1, 0, 0 ,  +1, 0, 0,  
			  -1, 0, 0,   -1, 0, 0,   -1, 0, 0,   -1, 0, 0,   
			  0, -1, 0,   0, -1, 0,   0, -1, 0,   0, -1, 0,   
			  0, +1, 0,   0, +1, 0,   0, +1, 0,   0, +1, 0,   
			  0, 0, +1,   0, 0, +1,   0, 0, +1,   0, 0, +1,   
			  0, 0, -1,   0, 0, -1,   0, 0, -1,   0, 0, -1 )
		m.indices.push(
			  0, 1, 2, 0, 2, 3,   4, 5, 6, 4, 6, 7,   8, 9, 10, 8, 10, 11, 
			  12, 13, 14, 12, 14, 15,   16, 17, 18, 16, 18, 19,   20, 21, 22, 20, 22, 23 )
		return m
	}

	function makeCylinder(R) {
		var N = 50 // number of sides of the cylinder, of radius 1 and axis < 1,0,0 >
		// Total number of vertices is 4*N+2 = 202 for N = 50
		var dtheta = 2*Math.PI/N
		var sind = Math.sin(dtheta), cosd = Math.cos(dtheta)
		// sin(theta+dtheta) = sin(theta)*cosd + cos(theta)*sind, so newy = y*cosd + z*sind
		// cos(theta+dtheta) = cos(theta)*cosd - sin(theta)*sind, so newz = z*cosd - y*sind
		var y = 0, z = R
		var newy, newz
		var m = new Mesh()
		m.vertices = [ 0, 0, 0, 1, 0, 0]
		m.normals = [ -1, 0, 0, 1, 0, 0]
		m.indices = []
		for (var i=2; i<2+4*N; i+=4) {
			newy = y*cosd + z*sind
			newz = z*cosd - y*sind
			
			m.vertices.push( 0,y,z,  0,y,z,  1,y,z,  1,y,z )
												  
			m.normals.push( -1,0,0,  0,y,z,  0,y,z,  1,0,0 )
												
			if (i == 2+4*(N-1)) {
				m.indices.push( 0,i,2,    i+1,i+2,4,    i+1,4,3,      1,5,i+3  )
			} else {
				m.indices.push( 0,i,i+4,  i+1,i+2,i+6,  i+1,i+6,i+5,  1,i+7,i+3  )
			}
			
			y = newy
			z = newz
		}
		return m
	}
	
	function makeCurveSegment(R) {
		// A low-triangle-count cylinder with a sphere at one end, to be rendered using the "curve_vertex" program
		// which will stretch the cylinder, but not the sphere, over the length of the segment.  To make this possible,
		// we provide 4D vertices x,y,z,w, with w=0 being the beginning of the segment and w=1 the end.  So x=1 is always
		// a radius away from x=0, but w=1 is a segment-length away from w=0.

		// An open-ended low-triangle-count cylinder for segments of a curve object
		var N = 8 // number of sides of the cylinder, of radius 1 and axis < 1,0,0 >
		// Total number of vertices is 2*N = 16 for N = 8
		var dtheta = 2*Math.PI/N
		var sind = Math.sin(dtheta), cosd = Math.cos(dtheta)
		// sin(theta+dtheta) = sin(theta)*cosd + cos(theta)*sind, so newy = y*cosd + z*sind
		// cos(theta+dtheta) = cos(theta)*cosd - sin(theta)*sind, so newz = z*cosd - y*sind
		var y = 0, z = R
		var newy, newz
		var m = new Mesh()
		m.vertices = []
		m.normals = []
		m.indices = []
		for (var i=0; i<2*N; i+=2) {
			newy = y*cosd + z*sind
			newz = z*cosd - y*sind
			
			m.vertices.push( 0,y,z,0,  0,y,z,1 )
			m.normals.push(  0,y,z,  0,y,z )
												
			if (i == 2*(N-1)) {
				m.indices.push( i,i+1,1,    i,1,0  )
			} else {
				m.indices.push( i,i+1,i+3,  i,i+3,i+2  )
			}
			
			y = newy
			z = newz
		}

		// This would just be m.merge( makeSphere(R,N) ), but we have to position the sphere at w=1
		var offset = m.vertices.length/4
		var sph = new makeSphere(R, N)
		for(var i=0; i<sph.vertices.length; i+=3)
			m.vertices.push( sph.vertices[i], sph.vertices[i+1], sph.vertices[i+2], 1 )
		for(var i=0; i<sph.normals.length; i++)
			m.normals.push(sph.normals[i])
		for(var i=0; i<sph.indices.length; i++)
			m.indices.push(sph.indices[i] + offset)
		return m
	}
	
	function makeCone(R) {
		// This cone algorithm gives the same unsmooth display as PhiloGL and should be changed to use the
		// VPython algorithm, which apparently generates a series of rings in order to make the cone smooth.
		// Dave: You shouldn't need vertical slices to make the cone smooth.  I think you just need two triangles per "face" of the cone,
		//    so the normals on the edges can be different at the tip
		
		var N = 100 // number of sides of the cone, of radius 1 and axis < 1,0,0 >
		// Total number of vertices is 3*N+1 = 301 for N = 100 (not smooth enough with N = 50)
		var dtheta = 2*Math.PI/N
		var sind = Math.sin(dtheta), cosd = Math.cos(dtheta)
		var k = 1/Math.sqrt(2)
		// sin(theta+dtheta) = sin(theta)*cosd + cos(theta)*sind, so newy = y*cosd + z*sind
		// cos(theta+dtheta) = cos(theta)*cosd - sin(theta)*sind, so newz = z*cosd - y*sind
		var y = 0, z = R
		var newy, newz
		var m = new Mesh()
		m.vertices.push( 0, 0, 0 )
		m.normals.push( -1, 0, 0 )
		for (var i=1; i<1+3*N; i+=3) {
			newy = y*cosd + z*sind
			newz = z*cosd - y*sind
			
			m.vertices.push( 0,y,z,  0,y,z,      1,0,0 )
			m.normals.push( -1,0,0,  k,k*y,k*z,  k,k*(y+newy)/2,k*(z+newz)/2 )
												
			if (i == 1+3*(N-1)) {
				m.indices.push( 0,i,1,    i+1,i+2,2  )
			} else {
				m.indices.push( 0,i,i+3,  i+1,i+2,i+4  )
			}
			
			y = newy
			z = newz
		}
		return m
	}
	
	function makeSphere(R, N) { 
		// A scheme which used spherical symmetry didn't save any time and was somewhat harder to read.
		// An improvement would be to offset alternate latitudes by dphi/2 to make equilateral triangles.
		var Nlat = N, Nlong = N   // number of latitude and longitude slices
		// Total number of vertices is Nlat*Nlong = 900 for Nlat = Nlong = 30
		// Total number of vertices is Nlat*Nlong =  64 for Nlat = Nlong =  8 for curve_segment
		var dtheta = Math.PI/Nlat   // polar angle (latitude)
		var dphi = 2*Math.PI/Nlong  // azimuthal angle (longitude)
		var sint = Math.sin(dtheta), cost = Math.cos(dtheta)
		var sinp = Math.sin(dphi), cosp = Math.cos(dphi)
		// sin(theta+dtheta) = sin(theta)*cost + cos(theta)*sint
		// cos(theta+dtheta) = cos(theta)*cost - sin(theta)*sint
		var m = new Mesh()
		var x1, x2, y1, y2, z1, z2, newy1, newz1, s, firstz2
		var i, j
		x1 = R // rightmost latitude in this latitude band
		y1 = 0
		z1 = 0
		for (i=0; i<Nlat; i++) { 
			if (i == Nlat-1) {
				for (j=0; j<Nlong; j+=1) {
					m.vertices.push( -R,0,0 )
					m.normals.push( -1,0,0 )
				}
			} else {
				x2 = x1*cost-z1*sint // leftmost latitude in this latitude band
				y2 = 0
				firstz2 = z2 = z1*cost+x1*sint
				for (j=0; j<Nlong; j+=1) {
					newy1 = y1*cosp+z1*sinp
					newz1 = z1*cosp-y1*sinp
					
					m.vertices.push( x1,y1,z1 )
					m.normals.push( x1/R,y1/R,z1/R )
					
					s = i*Nlong
					if (j == Nlong-1) {
						m.indices.push( s+j,s,s+Nlong,  s+j,s+Nlong,s+j+Nlong )
					} else {
						m.indices.push( s+j,s+j+1,s+j+1+Nlong,  s+j,s+j+1+Nlong,s+j+Nlong )
					}
					
					y1 = newy1
					z1 = newz1
				}
				x1 = x2
				y1 = 0
				z1 = firstz2
				}
		}
		return m
	}
	
	function makePyramid() {
		// pyramid has base that is length (x) by width (z) by height (y); default axis is < 1,0,0 >
		var m = new Mesh()
		m.vertices.push(
				0,.5,.5,   0,.5,-.5,  0,-.5,-.5,  0,-.5,.5,  // base (on left)
				0,.5,-.5,   0,.5,.5,    1,0,0,  // top
				0,-.5,-.5,  0,.5,-.5,   1,0,0,  // back
				0,-.5,.5,   0,-.5,-.5,  1,0,0,  // bottom
				0,.5,.5,    0,-.5,.5,   1,0,0 ) // front
		m.normals.push(
				-1,0,0,  -1,0,0,  -1,0,0,  -1,0,0,  // base (on left)
				1,2,0,   1,2,0,   1,2,0,  // top
				1,0,-2,  1,0,-2,  1,0,-2, // back
				1,-2,0,  1,-2,0,  1,-2,0, // bottom
				1,0,2,   1,0,2,   1,0,2 ) // front
		m.indices.push(0,1,2,  0,2,3,  4,5,6,  7,8,9,  10,11,12,  13,14,15)
		return m
	}

	function message(msg) {
		$("#message").text(msg.toString())
	}

	var exports = {
		scene: scene,
		on: on,
		waitfor: waitfor,
		message: message,
	}

	// For now, just dump all exports into the global scope
	for(var id in exports)
		window[id] = exports[id]
})();
/*
GlowScript was begun in the summer of 2011 by David Scherer and Bruce Sherwood
to implement an API for JavaScript/WebGL based on that of VPython (vpython.org).
 
Help from the following people in getting started is gratefully acknowledged:
Greg Sonnenfeld, Owen Densmore, and Nicolas Garcia Belmonte.
 
Feel free to use or modify this material for any purpose, but please retain this notice.
*/

(function () {
	"use strict";

	var exports = {}

	var lastrate = 0 // time of last call to rate()
	var lastrender = 0 // time of last transmission of data to render
	
	function radians(deg) { return (deg*Math.PI/180) }
	
	function degrees(rad) { return (rad*180/Math.PI) }

	var color = {
		red: vec(1, 0, 0),
		green: vec(0, 1, 0),
		blue: vec(0, 0, 1),
		yellow: vec(1, 1, 0),
		orange: vec(1, 0.6, 0),
		cyan: vec(0, 1, 1),
		magenta: vec(1, 0, 1),
		white: vec(1, 1, 1),
		black: vec(0, 0, 0),
		gray: function (g) { return vec(g, g, g) },
		hsv_to_rgb: function (hsv) { // algorithm from Python colorsys module
			var h = hsv.x
			var s = hsv.y
			var v = hsv.z
			if (s == 0) { return vec(v, v, v) }
			var i = Math.floor(6 * h)
			var f = (6 * h) - i
			var p = v * (1 - s)
			var q = v * (1 - s * f)
			var t = v * (1 - s * (1 - f))
			var i = i % 6
			switch (i) {
				case 0:
					return vec(v, t, p)
				case 1:
					return vec(q, v, p)
				case 2:
					return vec(p, v, t)
				case 3:
					return vec(p, q, v)
				case 4:
					return vec(t, p, v)
				case 5:
					return vec(v, p, q)
					// other cases are not possible
			}
		},
		rgb_to_hsv: function (rgb) { // algorithm from Python colorsys module
			var r = rgb.x
			var g = rgb.y
			var b = rgb.z
			var maxc = Math.max(r, g, b)
			var minc = Math.min(r, g, b)
			var v = maxc
			if (minc == maxc) { return vec(0, 0, v) }
			var s = (maxc - minc) / maxc
			var rc = (maxc - r) / (maxc - minc)
			var gc = (maxc - g) / (maxc - minc)
			var bc = (maxc - b) / (maxc - minc)
			var h
			if (r == maxc) {
				h = bc - gc
			} else if (g == maxc) {
				h = 2 + rc - bc
			} else {
				h = 4 + gc - rc
			}
			h = (h / 6) % 1
			return vec(h, s, v)
		}
	}
	
	var cot_hfov = 1/Math.tan(scene.__fov/2)
	
	function point_extent(obj,p) {
		scene.__extent.xmin = Math.min(p.x, scene.__extent.xmin)
		scene.__extent.ymin = Math.min(p.y, scene.__extent.ymin)
		scene.__extent.zmin = Math.min(p.z, scene.__extent.zmin)
		scene.__extent.xmax = Math.max(p.x, scene.__extent.xmax)
		scene.__extent.ymax = Math.max(p.y, scene.__extent.ymax)
		scene.__extent.zmax = Math.max(p.z, scene.__extent.zmax)
		
		obj.__xmin = Math.min(p.x, obj.__xmin)
		obj.__ymin = Math.min(p.y, obj.__ymin)
		obj.__zmin = Math.min(p.z, obj.__zmin)
		obj.__xmax = Math.max(p.x, obj.__xmax)
		obj.__ymax = Math.max(p.y, obj.__ymax)
		obj.__zmax = Math.max(p.z, obj.__zmax)
	}

	function find_extent(obj) {
		var size = obj.__size
		var start = obj.__pos
		var center_pos = obj.__hasPosAtCenter
		var length;
		if (center_pos)
			length = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z)/2
		else
			length = Math.sqrt(size.x*size.x + size.y*size.y/4 + size.z*size.z/4)
		if (!scene.__extent.find_autocenter) {
			// Quick check for whether this changed object can affect autoscaling
			var p = start.sub(scene.__center)
			var zzx = (Math.abs(p.x)+length)*cot_hfov + Math.abs(p.z)+length
			var zzy = (Math.abs(p.y)+length)*cot_hfov + Math.abs(p.z)+length
			if (zzx < scene.__extent.zx_camera && zzy < scene.__extent.zy_camera) {
				obj.__zx_camera = null  // obj.__zx_camera is no longer correct
				obj.__zy_camera = null
				return
			}
		}
		var axis = obj.__axis.norm()
		var up = obj.__up.norm()
		if (center_pos) start = start.sub(axis.multiply(size.x/2))
		var long = axis.multiply(size.x)
		var z = axis.cross(up).norm()
		if (z.dot(z) < 1e-10) {
			z = axis.cross(vec(1,0,0)).norm()
			if (z.dot(z) < 1e-10) z = axis.cross(vec(0,1,0)).norm()
		}
		var y = z.cross(axis)
		var pt1 = start.add(y.multiply(-size.y/2).add(z.multiply(-size.z/2)))
		var pt2 = pt1.add(y.multiply(size.y))
		var pt3 = pt1.add(z.multiply(size.z))
		var pt4 = pt2.add(z.multiply(size.z))
		var pt5 = pt1.add(long)
		var pt6 = pt2.add(long)
		var pt7 = pt3.add(long)
		var pt8 = pt4.add(long)
		
		point_extent(obj,pt1)
		point_extent(obj,pt2)
		point_extent(obj,pt3)
		point_extent(obj,pt4)
		point_extent(obj,pt5)
		point_extent(obj,pt6)
		point_extent(obj,pt7)
		point_extent(obj,pt8)
	}

	function subclass(sub, base) {
		sub.prototype = new base({ visible: 0 })
		sub.prototype.constructor = sub
	}

	function declareVectorAttr(obj, name, defaultValue) {
		var internal_name = '__' + name
		Object.defineProperty(obj.prototype, internal_name, { enumerable: false, writable: true, value: defaultValue })
		Object.defineProperty(obj.prototype, name, {
			enumerable: true,
			get: function () { return this[internal_name] },
			set:
				function (value) {
					// attributeVector() will set the changed status
					this[internal_name] = attributeVector(this, value.x, value.y, value.z)
				}
		});
	}

	function declareDerivedAttr(obj, name, getter, setter) {
		Object.defineProperty(obj.prototype, name, {
			enumerable: true,
			get: getter,
			set: function (value) { setter.call(this, value); this.__change() }
		})
	}

	function declareAttr(obj, name, attrType, defaultValue) {
		var internal_name = '__' + name

		Object.defineProperty(obj.prototype, internal_name, { enumerable: false, writable: true, value: attrType(defaultValue) })
		Object.defineProperty(obj.prototype, name, {
			enumerable: true,
			get: function () { return this[internal_name] },
			set: function (value) { this[internal_name] = attrType(value); this.__change() }
		})
	}

	function initObject(obj, constructor, args) {
		if (!(obj instanceof constructor)) return new constructor(args)  // so box() is like new box()

		if (args === undefined) args = {}  // so box() is like box({})

		if (current_canvas === null) canvas()

		// We have to initialize ALL vector attributes here, because they need pointers back to this :-(
		if (args.pos === undefined) obj.pos = obj.pos
		if (args.color === undefined) obj.color = scene.foreground
		if (args.axis === undefined) obj.axis = obj.axis
		if (args.up === undefined) obj.up = scene.up
		if (args.size === undefined) {
			obj.size = obj.size
			if (obj.constructor === ring) obj.__size.x = 0.1 // exception to size (1,1,1)
		}

		// We have to set visible unless args has visible:false
		if (args.visible === undefined) args.visible = true

		for (var id in args) {
			obj[id] = args[id]
		}
	}

	// For now, ids are ever-increasing.  Perhaps change this to keep a compact list
	// of indices, or lists of different primitive types if that is convenient to the renderer
	var nextVisibleId = 1

	function Primitive() {
	}
	Object.defineProperty(Primitive.prototype, '__id', { enumerable: false, writable: true, value: null })
	Object.defineProperty(Primitive.prototype, '__hasPosAtCenter', { enumerable: false, writable: true, value: false })
	Object.defineProperty(Primitive.prototype, 'visible', {
		enumerable: true,
		get:
			function () { return this.__id != null },
		set:
			function (value) {
				if (value == (this.__id != null)) return;
				if (value) {
					this.__id = nextVisibleId
					nextVisibleId++
					scene.__visiblePrimitives[this.__id] = this
					scene.__changed[this.__id] = this
				} else {
					delete scene.__visiblePrimitives[this.__id]
					delete scene.__changed[this.__id]
					if (this.__model) delete this.__model.id_object[this.__id]
					if (this.__components)
						for (var i = 0; i < this.__components.length; i++)
							delete this.__components[i].__model.id_object[this.__components[i].__id]
						this.__id = null
					}
				}
	})
	Primitive.prototype.__change = function () {
		if (this.__id) scene.__changed[this.__id] = this
	}
	Primitive.prototype.__get_extent = function () {
		find_extent(this)
	}
	Primitive.prototype.__update = function () {
		var pos = this.__pos
		var size = this.__size
		var color = this.__color
		var axis = this.__axis
		var up = this.__up

		var data = this.__data
		if (!data) this.__data = data = new Float32Array(20)
		this.__model.id_object[this.__id] = data

		data[0] = pos.__x
		data[1] = pos.__y
		data[2] = pos.__z

		data[4] = axis.__x
		data[5] = axis.__y
		data[6] = axis.__z

		data[8] = up.__x
		data[9] = up.__y
		data[10] = up.__z

		data[12] = size.__x
		data[13] = size.__y
		data[14] = size.__z

		data[16] = color.__x
		data[17] = color.__y
		data[18] = color.__z
		data[19] = this.opacity
	}
  
	Primitive.prototype.rotate = function (angle, axis, origin) {
		if (angle === undefined) { throw new Error("object.rotate() requires an angle") }
		if (axis === undefined) { axis = this.__axis }
		if (origin === undefined) { origin = this.__pos }
		var X = axis.norm()
		var fake_up = this.__up.norm()
		var Z = X.cross(fake_up).norm()
		if (Z.dot(Z) < 1e-10) {
			Z = X.cross(vec( 1,0,0))
			if (Z.dot(Z) < 1e-10)
				Z = cross(X,vec( 0,1,0))
			fake_up = Z.cross(X)
		}
		this.pos = origin.add(this.__pos.sub(origin).rotate(angle, axis))
		this.axis = this.__axis.rotate(angle, axis)
		this.up = fake_up.rotate(angle, X)
	}
	
	// Actually I don't know why null is better than undefined for these, 
	// but certainly they should not be initialized in initObject!
	Primitive.prototype.__zx_camera = Primitive.prototype.__zy_camera = null
	Primitive.prototype.__xmin = Primitive.prototype.__ymin = Primitive.prototype.__zmin = null
	Primitive.prototype.__xmax = Primitive.prototype.__ymax = Primitive.prototype.__zmax = null
	declareVectorAttr(Primitive, 'pos', vec(0, 0, 0))
	declareVectorAttr(Primitive, 'color', vec(1, 1, 1))
	declareVectorAttr(Primitive, 'axis', vec(1, 0, 0))
	declareVectorAttr(Primitive, 'size', vec(1, 1, 1))
	declareVectorAttr(Primitive, 'up', vec(0, 1, 0))
	declareAttr(Primitive, 'opacity', Number, 1)
	Primitive.prototype.getTransformedMesh = function getTransformedMesh() {
		var X = this.axis.norm()
		var Z = X.cross(this.up.norm())
		if (Z.mag2() < 1e-10) {
			Z = X.cross(vec(1, 0, 0))
			if (Z.mag2() < 1e-10)
				Z = X.cross(vec(0, 1, 0))
		}
		Z = Z.norm()
		var Y = Z.cross(X).norm()
		X = X.multiply(this.size.x)
		Y = Y.multiply(this.size.y)
		Z = Z.multiply(this.size.z)
		var T = this.pos
		var matrix = [X.x, X.y, X.z, 0, Y.x, Y.y, Y.z, 0, Z.x, Z.y, Z.z, 0, T.x, T.y, T.z, 1]
		return this.__model.mesh.transformed(matrix);
	}

	function box(args) { return initObject(this, box, args) }
	subclass(box, Primitive)
	box.prototype.__hasPosAtCenter = true

	function cylinder(args) { return initObject(this, cylinder, args) }
	subclass(cylinder, Primitive)

	function cone(args) { return initObject(this, cone, args) }
	subclass(cone, cylinder)

	function pyramid(args) { return initObject(this, pyramid, args) }
	subclass(pyramid, box)

	function sphere(args) { return initObject(this, sphere, args) }
	subclass(sphere, Primitive)
	sphere.prototype.__hasPosAtCenter = true

	function arrow(args) { return initObject(this, arrow, args) }
	subclass(arrow, Primitive)
	arrow.prototype.__primitiveCount = 2
	// FIXME: In VPython, there are getters for these attributes that return the default values instead of 0
	declareAttr(arrow, 'shaftwidth', Number, 0)
	declareAttr(arrow, 'headwidth', Number, 0)
	declareAttr(arrow, 'headlength', Number, 0)
	declareDerivedAttr(Primitive, 'axis_and_length',
		function () { return this.__axis.norm().multiply(this.__size.x) },
		function (value) {
			this.axis = value
			this.__size.x = value.mag()
		})
	arrow.prototype.__update = function () {
		var pos = this.__pos; var color = this.__color
		var axis = this.__axis; var size = this.__size; var up = this.__up
		var L = size.__x
		var A = axis.norm()
		var sw = this.__shaftwidth || L * .1
		var hw = this.__headwidth || sw * 2
		var hl = this.__headlength || sw * 3

		if (sw < L * .02) {
			var scale = L * .02 / sw
			if (!this.__shaftwidth) sw *= scale
			if (!this.__headwidth) hw *= scale
			if (!this.__headlength) hl *= scale
		}
		if (hl > L * .5) {
			var scale = L * .5 / hl
			if (!this.__shaftwidth) sw *= scale
			if (!this.__headwidth) hw *= scale
			if (!this.__headlength) hl *= scale
		}

		var components = this.__components
		if (!components) {
			components = this.__components = [box({ visible: 0 }), pyramid({ visible: 0 })]
			for (var i = 0; i < components.length; i++)
				components[i].__id = nextVisibleId++;
		}
		var shaft = components[0]
		var tip = components[1]

		shaft.pos = pos.add(A.multiply(.5 * (L - hl)))
		tip.pos = pos.add(A.multiply(L - hl))
		shaft.axis = tip.axis = axis
		shaft.up = tip.up = up
		shaft.size = vec(L - hl, sw, sw)
		tip.size = vec(hl, hw, hw)
		shaft.color = tip.color = this.color
		shaft.opacity = tip.opacity = this.opacity

		this.size = vec(L, hw, hw)

		shaft.__update()
		tip.__update()
	}

	function curve(args) {
		if (!(this instanceof curve)) return new curve(args)  // so curve() is like new curve()

		if (current_canvas === null) canvas()

		this.points = []
		this.radius = .001 * scene.__range  // This should be 0, indicating a 1-pixel curve
		this.color = this.color

		this.__id = nextVisibleId++;

		for (var id in args)
			this[id] = args[id]
	}
	declareAttr(curve, 'radius', Number, 0)
	declareVectorAttr(curve, 'color', vec(1, 1, 1))
	// TODO: curve.visible
	curve.prototype.__change = function () {
		if (this.__id) scene.__changed[this.__id] = this
	}
	// This has no effect; curve isn't autoscaled yet:
	curve.prototype.__get_extent = function () {
		point_extent(this,this.pos)
	}
	curve.prototype.__update = function () {
		// An update here means that something affecting the *entire* curve has changed
		// update all the points (note that some points might have changed individually, too, and get updated twice)
		for (var i = 0; i < this.points.length; i++)
			this.points[i].__update()
	}
	curve.prototype.push = function (pt) {
		pt.__curve = this
		pt.__id = nextVisibleId++
		if (this.points.length) {
			var prev = this.points[this.points.length - 1]
			var s = pt.__prevsegment = prev.__nextsegment = new Float32Array(16)
			s[11] = s[15] = 1;  // opacities
			this.__model.id_object[pt.__id] = s
			prev.__change()
		} // TODO: else do something clever to cap the beginning of the curve
		this.points.push(pt)
		pt.__change()
	}

	// As currently defined, point is really solely a curve point.  
	function point(pos, args) {
		if (!(this instanceof point)) return new point(pos, args)
		this.pos = pos
		for (var id in args)
			this[id] = args[id]
	}
	point.prototype.__curve = null
	declareVectorAttr(point, 'pos', vec(0, 0, 0))
	declareAttr(point, 'color', function (x) { return x }, null)
	declareAttr(point, "radius", function (x) { return x }, null)
	point.prototype.__change = function () {
		if (this.__id) scene.__changed[this.__id] = this
	}
	point.prototype.__update = function () {
		var pos = this.__pos
		var radius = this.__radius || this.__curve.__radius
		var color = this.__color || this.__curve.__color
		var s = this.__prevsegment
		if (s) {
			s[4] = pos.x
			s[5] = pos.y
			s[6] = pos.z
			s[7] = radius
			s[12] = color.x;
			s[13] = color.y;
			s[14] = color.z;
		}
		s = this.__nextsegment
		if (s) {
			s[0] = pos.x
			s[1] = pos.y
			s[2] = pos.z
			s[3] = radius
			s[8] = color.x;
			s[9] = color.y;
			s[10] = color.z;
		}
	}

	function helix(args) { return initObject(this, helix, args) }
	subclass(helix, Primitive)

	helix.prototype.__thickness = null
	helix.prototype.__coils = 5
	helix.prototype.__initialize = true

	helix.prototype.__update = function () {
		var NCHORDS = 20 // number of chords in one coil of a helix

		if (this.__initialize) {
			if (this.__helix !== undefined) {
				for (var i = 0; i < this.__helix.points.length; i++)
					this.__helix.points[i].pos = this.__pos
				this.__helix.__update()
				this.__helix.points = []
			} else {
				this.__helix = curve()
				this.__helix.__id = nextVisibleId++
			}
		}
		var c = this.__helix
		// Should update the curve's color separately; no need to update vertices
		c.color = this.__color
		if (this.__thickness === null) c.radius = this.__size.y/40
		else c.radius = this.__thickness / 2

		var X = this.__axis.norm()
		var Y, Z
		Z = X.cross(this.__up)
		if (Math.abs(dot(Z, Z)) < 1e-10) {
			Z = X.cross(vec(1, 0, 0))
			if (Math.abs(dot(Z, Z)) < 1e-10) {
				Z = X.cross(vec(0, 1, 0))
			}
		}
		Z = Z.norm()
		Y = Z.cross(X)

		var r = this.__size.y/2
		var count = this.__coils * NCHORDS
		var dr = this.__axis.norm().multiply(this.__size.x / count)
		var ds = Math.sin(2 * Math.PI / NCHORDS), dc = Math.cos(2 * Math.PI / NCHORDS)
		var dy = r * ds, dz = -r * (1 - dc)
		var dznew

		// Make a table of vector increments per coil
		var drs = []
		for (var i = 0; i < NCHORDS; i++) {
			drs.push(dr.add(Y.multiply(dy)).add(Z.multiply(dz)))
			dznew = dz * dc - dy * ds
			dy = dy * dc + dz * ds
			dz = dznew
		}

		// Use the table of increments to calculate the vertices
		var v = this.__pos.add(Z.multiply(r))

		for (var i = 0; i <= count; i++) {
			if (this.__initialize) {
				c.push(point(v))
			} else {
				c.points[i].pos = v
			}
			v = v.add(drs[i % NCHORDS])
		}

		c.__update()
		this.__initialize = false
	}
	declareDerivedAttr(helix, 'coils',
		function () { return this.__coils },
		function (value) {
			this.__coils = value
			this.__initialize = true
			this.__change()
		})
	declareDerivedAttr(helix, 'thickness', // thickness of curve; need not update helix, just its curve
		function () { return this.__thickness },
		function (value) {
			this.__thickness = value
			if (this.__helix !== undefined) this.__helix.radius = value / 2
		})

	function ring(args) { return initObject(this, ring, args) }
	subclass(ring, Primitive)
	// This is a temporary implementation of ring, using curve.
	// Because curve doesn't currently average the normals of adjacent segments,
	// it is necessary to use an unusually large number for NCHORDS.

	ring.prototype.__initialize = true
	ring.prototype.__hasPosAtCenter = true

	ring.prototype.__update = function () {

		if (this.__initialize) {
			if (this.__ring !== undefined) {
				for (var i = 0; i < this.__ring.points.length; i++)
					this.__ring.points[i].pos = this.__pos
				this.__ring.__update()
				this.__ring.points = []
			} else {
				this.__ring = curve()
				this.__ring.__id = nextVisibleId++
			}
		}
		var c = this.__ring
		// Should update the curve's color separately; no need to update vertices
		c.color = this.__color
		c.radius = this.__size.x/2

		var X = this.__axis.norm()
		var Y, Z
		Z = X.cross(this.__up)
		if (Math.abs(dot(Z, Z)) < 1e-10) {
			Z = X.cross(vec(1, 0, 0))
			if (Math.abs(dot(Z, Z)) < 1e-10) {
				Z = X.cross(vec(0, 1, 0))
			}
		}
		Z = Z.norm()
		Y = Z.cross(X)

		var NCHORDS = 100 // number of chords
		var r = (this.__size.y-this.__size.x)/2
		var rcos = r, rsin = 0, newrsin
		var ds = Math.sin(2 * Math.PI / NCHORDS), dc = Math.cos(2 * Math.PI / NCHORDS)
		var start = this.__pos

		for (var i = 0; i <= NCHORDS; i++) {
			var v = start.add(Y.multiply(rsin)).add(Z.multiply(rcos))
			if (this.__initialize) {
				c.push(point(v))
			} else {
				c.points[i].pos = v
			}
			newrsin = rsin * dc + rcos * ds
			rcos = rcos * dc - rsin * ds
			rsin = newrsin
		}

		c.__update()
		this.__initialize = false
	}
	
	function distant_light(dir, color) {
		if (!(this instanceof distant_light)) return new distant_light(dir, color)  // so distant_light() is like new distant_light()
		
		if (current_canvas === null) canvas()
		
		if (dir !== undefined) this.__direction = dir
		else throw new Error("Must specify a direction for a distant_light")
		if (color !== undefined) this.__color = color
		scene.lights.push(this)
	}
	declareVectorAttr(distant_light, 'direction', vec(0,0,1))
	declareVectorAttr(distant_light, 'color', vec(1,1,1))
	
	distant_light.prototype.__change = function () {
		scene.__labels.__changed = true
	}
	
	function local_light(pos, color) {
		if (!(this instanceof local_light)) return new local_light(pos, color)  // so local_light() is like new local_light()
		
		if (current_canvas === null) canvas()
		
		if (pos !== undefined) this.__pos = pos
		else throw new Error("Must specify a direction for a local_light")
		if (color !== undefined) this.__color = color
		scene.lights.push(this)
	}
	declareVectorAttr(local_light, 'pos', vec(0,0,0))
	declareVectorAttr(local_light, 'color', vec(1,1,1))
	
	local_light.prototype.__change = function () {
		scene.__labels.__changed = true
	}
	
	function label(args) {
		if (!(this instanceof label)) return new label(args)  // so label() is like new label()

		if (current_canvas === null) canvas()

		this.__pos = vec(0, 0, 0)
		this.__color = scene.foreground
		this.__linecolor = null
		this.__text = ''
		this.__font = 'Verdana'
		this.__height = 13
		this.__visible = true
		this.__align = 'center'
		this.__box = 'true'
		this.__border = 5
		this.__xoffset = 0
		this.__yoffset = 0
		this.__space = 0
		for (var attr in args) {
			this['__' + attr] = args[attr]
		}
		// We have to initialize ALL vector attributes here, because they need pointers back to this :-(
		this.pos = this.pos
		this.color = this.color
		scene.__labels.label_objects.push(this) // simple scheme for now
	}

	label.prototype.__update = function (ctx, camera) {
		if (scene.__width >= scene.height) var factor = 2 * scene.__range / scene.__height // real coord per pixel
		else var factor = 2 * scene.__range / scene.__width
		var vnew = mat4.multiplyVec3(
			mat4.rotateY(mat4.rotateX(mat4.identity(mat4.create()), camera.angleY), camera.angleX),
			vec3.create([this.pos.x - scene.center.x, this.pos.y - scene.center.y, this.pos.z - scene.center.z]))
		var d = camera.distance
		var k = (1 + vnew[2] / (d - vnew[2])) / factor
		var posx = Math.round(k * vnew[0] + scene.__width / 2) // label.pos in terms of pixels
		var posy = Math.round(-k * vnew[1] + scene.__height / 2)
		// Need to check for wrap-around of label, but this isn't right:
		//if (vnew[2] < camera.zNear || vnew[2] > camera.zFar) return

		ctx.font = this.height + 'px ' + this.font
		ctx.fillStyle = color_to_js_color(this.color)
		var linecolor = this.color
		if (!(this.linecolor === null)) linecolor = this.linecolor
		ctx.strokeStyle = color_to_js_color(linecolor)
		ctx.textAlign = 'left' // make explicit to simplify/clarify later calculations
		ctx.textBaseline = 'middle'

		var tx = posx, ty = posy
		var xoffset = this.xoffset, yoffset = this.yoffset
		var twidth = ctx.measureText(this.text).width
		var tw, th, xleft, ytop, xend, yend
		if (this.box || xoffset || yoffset) {
			tw = Math.ceil(twidth)
			th = Math.ceil(this.height + 2 * this.border)
			xleft = Math.floor(tx - this.border) + 0.5
			ytop = Math.ceil(ty - .4 * th) - 0.5
		}
		if (xoffset || yoffset) {
			if (Math.abs(yoffset) > Math.abs(xoffset)) {
				if (yoffset > 0) {
					ytop -= yoffset + th / 2
					ty -= yoffset + th / 2
					yend = ytop + th
				} else {
					ytop -= yoffset - th / 2
					ty -= yoffset - th / 2
					yend = ytop
				}
				tx += xoffset - tw / 2
				xleft = tx - this.border
				xend = tx + tw / 2
			} else {
				if (xoffset > 0) {
					xleft += xoffset
					tx += xoffset
					xend = xleft
				} else {
					tx += xoffset - tw
					xleft = tx - this.border
					xend = tx + tw + this.border
				}
				ty -= yoffset
				ytop -= yoffset
				yend = ytop + th / 2
			}
			ctx.beginPath()
			if (this.space > 0) {
				var v = (vec(xend - posx, yend - posy, 0).norm()).multiply(k*this.space)
				v = v.add(vec(posx, posy, 0))
				ctx.moveTo(v.x, v.y)
			} else ctx.moveTo(posx, posy)
			ctx.lineTo(xend, yend)
			ctx.stroke()
		} else {
			switch (this.align) {
				case 'center':
					tx -= twidth / 2
					xleft -= twidth / 2
					break
				case 'right':
					tx -= twidth
					xleft -= twidth
			}
		}
		if (this.box) {
			tw += 2 * this.border
			ctx.beginPath()
			ctx.moveTo(xleft, ytop)
			ctx.lineTo(xleft + tw, ytop)
			ctx.lineTo(xleft + tw, ytop + th)
			ctx.lineTo(xleft, ytop + th)
			ctx.closePath()
			ctx.stroke()
		}
		ctx.fillText(this.text, tx, ty)
	}

	declareVectorAttr(label, 'pos', vec(0, 0, 0))
	declareVectorAttr(label, 'color', vec(1, 1, 1))
	declareVectorAttr(label, 'linecolor', vec(1, 1, 1))
	declareAttr(label, 'text', String, '')
	declareAttr(label, 'font', String, '')
	declareAttr(label, 'height', Number, 13)
	declareAttr(label, 'visible', Number, 1)
	declareAttr(label, 'align', String, 'center')
	declareAttr(label, 'box', Number, 1)
	declareAttr(label, 'border', Number, 5)
	declareAttr(label, 'xoffset', Number, 0)
	declareAttr(label, 'yoffset', Number, 0)
	declareAttr(label, 'space', Number, 0)

	label.prototype.__change = function () {
		scene.__labels.__changed = true
	}

	function sleep(dt, cb) { // sleep for dt seconds
		function wrapCB() { cb() } // In firefox, setTimeout callback is invoked with a random integer argument, which streamline will interpret as an error!
		setTimeout(wrapCB, 1000 * dt)
	}

	function update(cb) {
		sleep(0, cb)
	}

	function rate(iters, cb) {
		if (cb === undefined)
			throw new Error("rate() called without _");
		var dt = 1 / iters
		lastrate += dt
		var t = new Date().getTime() * .001
		if (lastrate > t) {
			sleep(lastrate - t, cb)
		} else {
			if (lastrate < t - 0.1) lastrate = t
			cb()
		}
	}

	function compound(objects, parameters) {
		if (!(this instanceof compound)) return new compound(objects, parameters);
		var Model = this.__model
		var mesh = new Model.Mesh()
		for (var i = 0; i < objects.length; i++) {
			var o = objects[i]
			o.visible = false
			mesh.merge(o.getTransformedMesh())
		}
		this.__model = Model(mesh)
		initObject(this, compound, parameters)

		// Define a new *class* of compound primitive compound(...).clone
		var clone = function (parameters) {
			if (!(this instanceof clone)) return new clone(parameters)
			this.__id = null;
			return initObject(this, clone, parameters)
		}
		clone.prototype = this
		clone.prototype.constructor = clone
		this.clone = clone
	}
	subclass(compound, box)

	/////////////////// beginnings of setting canvas

	var current_canvas = null
	var canvas_list = []

	function _canvas(options) {
		var width = 640
		var height = 400
		var base = document.getElementById('glowscript')
		// Should width/height in html take precendence over width/height specified in canvas()?
		//if (base.getAttribute('width') !== null) width = base.getAttribute('width')
		//if (base.getAttribute('height') !== null) height = base.getAttribute('height')
		if (options !== undefined) {
			if (options.width !== undefined) width = options.width
			if (options.height !== undefined) height = options.height
		}

		var cv = document.createElement('canvas')
		cv.style.position = 'absolute'
		cv.setAttribute('width', width)
		cv.setAttribute('height', height)
		base.appendChild(cv)

		var overlay = document.createElement('canvas')
		overlay.setAttribute('width', width)
		overlay.setAttribute('height', height)
		overlay.style.backgroundColor = "transparent"
		overlay.style.position = "relative"
		overlay = base.appendChild(overlay)

		scene.setCanvas(cv, overlay)
	}

	function canvas(options) {
		if (current_canvas != null) throw new Error("Only one canvas is supported at present")
		current_canvas = new _canvas(options)
		canvas_list.push(current_canvas)
		return scene
	}

	/////////////////// graphing machinery start:

	var current_graph = null
	var graph_list = []

	function graph_update() {
		var info, gd
		for (var g = 0; g < graph_list.length; g++) {
			gd = graph_list[g]
			if (!gd.changed) continue
			info = []
			for (var i = 0; i < gd.series.length; i++) {
				if (gd.series[i].visible) info.push(gd.series[i].options)
			}
			var make_plot = $.plot(gd.display, info, gd.options)
			make_plot.draw()
			gd.changed = false
		}
	}

	function _graph(options) {
		var width = 640
		var height = 200
		if (!(options === undefined || options.width === undefined)) width = options.width
		if (!(options === undefined || options.height === undefined)) height = options.height
		this.id = "__graph" + graph_list.length
		var graphing = '<div id=' + this.id + ' style="width:' + width + 'px;height:' + height + 'px"></div>'
		var marker = '#glowscript'
		if (current_graph) marker = "#" + current_graph.id
		$(graphing).insertAfter(marker)
		this.display = "#" + this.id
		if (options) {
			if (options.series) options.series.shadowSize = 0 // faster plotting without shadows
			else {
				options.series = { shadowSize: 0 }
			}
		} else options = { series: { shadowSize: 0} }

		this.options = options
		this.series = []
		this.changed = false

		this.add_to_graph = function (obj) {
			this.series.push(obj)
		}
	}

	function graph(options) {
		current_graph = new _graph(options)
		graph_list.push(current_graph)
		return current_graph
	}

	function color_to_js_color(color) {
		var r = Math.floor(255 * color.x)
		var g = Math.floor(255 * color.y)
		var b = Math.floor(255 * color.z)
		return 'rgb(' + r + ',' + g + ',' + b + ')'
	}

	function gobject(gtype, options) {

		this.gtype_to_flot_type = function (gtype) {
			switch (gtype) {
				case 'line':
					return 'lines'
				case 'scatter':
					return 'points'
				case 'bar':
					return 'bars'
			}
		}

		if (options === undefined) options = { data: [] }
		else if (options.data === undefined) options.data = []
		if (current_graph === null) {
			current_graph = graph()
		}
		this.__graph = current_graph
		if (!(options.graph === undefined)) {
			this.__graph = options.graph
			delete options.graph
		}
		this.__gtype = gtype // 'line', 'scatter', 'bar'
		this.__flot_type = this.gtype_to_flot_type(gtype)
		this.__delta = 1
		if (!(options.delta === undefined)) {
			this.__delta = options.delta
			delete options.delta
		}
		if (!(options[this.__flot_type] === undefined)) {
			options[this.__flot_type].show = true
			if (!(options[this.__flot_type].barWidth === undefined)) this.__delta = options[this.__flot_type].barWidth
			else options[this.__flot_type].barWidth = this.__delta
		} else {
			options[this.__flot_type] = { show: true, barWidth: this.__delta }
		}
		if (!(options.color === undefined)) {
			this.__color = options.color
			options.color = color_to_js_color(this.__color)
		} else this.__color = undefined
		if (options.data.length > 0) {
			this.__graph.changed = true
			if (gtype == 'bar') {
				for (var i = 0; i < options.data.length; i++) {
					options.data[i][0] -= this.__delta / 2
				}
			}
		}
		this.__visible = true
		if (!(options.visible === undefined)) {
			this.__visible = options.visible
			delete options.visible
		}
		this.options = options
		this.__graph.add_to_graph(this)

		this.plot = function (data) {
			// Accept plot(x,y) or plot([x,y], [x,y], ...) or plot([[x,y], [x,y], ...]])
			this.__graph.changed = true
			if (typeof arguments[0] == 'number') { // x,y
				if (this.__gtype == 'bar') arguments[0] -= this.__delta / 2
				this.options.data.push([arguments[0], arguments[1]])
			} else if (typeof arguments[0][0] == 'number') { // [x,y], [x,y], ....
				var xy
				for (var i = 0; i < arguments.length; i++) {
					xy = arguments[i]
					if (this.__gtype == 'bar') xy[0] -= this.delta / 2
					this.options.data.push(xy)
				}
			} else if (arguments.length == 1) {
				var xy
				for (var i = 0; i < data.length; i++) { // [ [x,y], [x,y], .... ]
					xy = data[i]
					if (this.__gtype == 'bar') xy[0] -= this.__delta / 2
					this.options.data.push(xy)
				}
			} else {
				throw new Error("must be plot(x,y) or plot([x,y]) or plot([x,y], ...) or plot([ [x,y], ... ])")
			}
		}
	}

	Object.defineProperty(gobject.prototype, '__graph', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'graph', {
		enumerable: true,
		get:
			function () { return this.__graph },
		set:
			function (value) {
				this.__graph.changed = true
				this.__graph.series.splice(this.__graph.series.indexOf(this), 1)
				this.__graph = value
				this.__graph.add_to_graph(this)
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__gtype', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'gtype', {
		enumerable: true,
		get:
			function () { return this.__gtype },
		set:
			function (value) {
				var oldvalue = this.__flot_type
				this.__gtype = value
				this.__flot_type = this.gtype_to_flot_type(value)
				if (this.__flot_type == oldvalue) return
				var oldvars = this.options[oldvalue]
				delete this.options[oldvalue]
				var sold = 0, snew = 0
				if (oldvalue == 'bars') {
					sold = this.__delta / 2
					delete oldvars.barWidth
				}
				this.options[this.__flot_type] = oldvars
				if (this.__flot_type == 'bars') {
					this.__delta = this.options[this.__flot_type].barWidth = 1 // default delta
					snew = this.__delta / 2
				}
				if (sold + snew != 0) {
					for (var i = 0; i < this.options.data.length; i++) {
						this.options.data[i][0] += (snew + sold)
					}
				}
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__color', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'color', {
		enumerable: true,
		get:
			function () { return this.__color },
		set:
			function (value) {
				this.__color = value
				this.options.color = color_to_js_color(value)
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__label', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'label', {
		enumerable: true,
		get:
			function () {
				if (this.options.label === undefined) return ''
				return this.options.label
			},
		set:
			function (value) {
				this.options.label = value
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__delta', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'delta', {
		enumerable: true,
		get:
			function () { return this.__delta },
		set:
			function (value) {
				var oldvalue = this.__delta
				this.__delta = value
				if (this.__gtype == 'gvbars') {
					for (var i = 0; i < this.options.data.length; i++) {
						this.options.data[i] += (oldvalue - value) / 2
					}
				}
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__visible', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'visible', {
		enumerable: true,
		get:
			function () { return this.__visible },
		set:
			function (value) {
				this.__visible = value
				this.__graph.changed = true
			}
	});
	Object.defineProperty(gobject.prototype, '__data', { enumerable: false, writable: true, value: 0 })
	Object.defineProperty(gobject.prototype, 'data', {
		enumerable: true,
		get:
			function () { return this.options.data },
		set:
			function (value) {
				this.options.data = []
				this.plot(value)
			}
	});

	function line(options) {
		return new gobject('line', options)
	}

	function scatter(options) {
		return new gobject('scatter', options)
	}

	function bar(options) {
		return new gobject('bar', options)
	}

	/////////////////// graphing machinery end

	// Add more math functions here, to emulate VPython environment:
	exports.sqrt = Math.sqrt
	exports.pi = Math.PI
	exports.abs = Math.abs
	exports.sin = Math.sin
	exports.cos = Math.cos
	exports.tan = Math.tan
	exports.asin = Math.asin
	exports.acos = Math.acos
	exports.atan = Math.atan
	exports.atan2 = Math.atan2
	exports.exp = Math.exp
	exports.log = Math.log
	exports.pow = Math.pow
	exports.radians = radians
	exports.degrees = degrees

	exports.box = box
	exports.cylinder = cylinder
	exports.cone = cone
	exports.pyramid = pyramid
	exports.sphere = sphere
	exports.arrow = arrow
	exports.curve = curve
	exports.helix = helix
	exports.ring = ring
	exports.label = label
	exports.point = point
	exports.distant_light = distant_light
	exports.local_light = local_light
	exports.compound = compound

	exports.color_to_js_color = color_to_js_color

	exports.color = color
	exports.sleep = sleep
	exports.update = update
	exports.rate = rate
	exports.canvas = canvas

	exports.graph = graph
	exports.line = line
	exports.scatter = scatter
	exports.bar = bar
	exports.graph_update = graph_update // called by render

	// For now, just dump all exports into the global scope
	for (var id in exports)
		window[id] = exports[id]
})()

shaders = {
"curve_vertex":'// Vertex shader for rendering curve segments, parameterized by\n// pos1, pos2, radius, color\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec4 position;  // position.w is 0 at the beginning of the segment and 1 at the end; \n                          // position.xyz are relative to that end in an normal basis with x pointing along the segment and scaled by radius\nattribute vec3 normal;\n\nuniform vec4 segmentData[4];\n#define segmentPosR(i) segmentData[i].xyzw\n#define segmentColor(i) segmentData[2+i].rgba\n\nuniform mat4 viewMatrix;\nuniform mat4 projMatrix;\n\nvarying vec3 es_position;     // eye space surface position\nvarying vec3 es_normal;       // eye space surface normal\nvarying vec3 mat_pos;         // surface material position in [0,1]^3\nvarying vec4 mat_color;\n\nmat3 getSegmentRotation() {\n  // Construct the object rotation matrix.  A waste to do this per vertex, but GPU >> CPU, especially javascript...\n  vec3 X = normalize( segmentData[1].xyz - segmentData[0].xyz );\n  vec3 Z = cross(X, vec3(0,1,0));  // TODO: Optimize constant cross product\n  if (dot(Z,Z) < 1e-10 )\n    Z = cross(X, vec3(1,0,0));\n  Z = normalize(Z);\n  return mat3( X, normalize(cross(Z,X)), Z );\n}\n\nvoid main(void) {\n  // A rotation matrix with x pointed along the segment\n  mat3 rot = getSegmentRotation();\n\n  // The position and radius of "this" end of the segment in world space\n  vec4 ws_segmentEnd = segmentPosR(0) * (1.-position.w) + segmentPosR(1) * position.w;\n\n  // The position of this vertex in world space\n  vec3 ws_pos = ws_segmentEnd.xyz + rot * (ws_segmentEnd.w*position.xyz);\n\n  es_normal = (viewMatrix * vec4(rot * normal, 0.0)).xyz;\n  vec4 pos4 = viewMatrix * vec4( ws_pos, 1.0);\n  es_position = pos4.xyz;\n  gl_Position = projMatrix * pos4;\n  mat_pos = position.xyz;\n  mat_color = segmentColor(0) * (1.-position.w) + segmentColor(1) * position.w;\n}',
"object_vertex":"// Vertex shader for rendering standard 'objects' parameterized by\n// pos, axis, up, scale, color\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nattribute vec3 position;\nattribute vec3 normal;\nuniform vec4 objectData[5];\n#define objectPos objectData[0].xyz\n#define objectAxis objectData[1].xyz\n#define objectUp objectData[2].xyz\n#define objectScale objectData[3].xyz\n#define objectColor objectData[4].rgba\nuniform mat4 viewMatrix;\nuniform mat4 projMatrix;\n\nvarying vec3 es_position;     // eye space surface position\nvarying vec3 es_normal;       // eye space surface normal\nvarying vec3 mat_pos;         // surface material position in [0,1]^3\nvarying vec4 mat_color;\n\nmat3 getObjectRotation() {\n  // Construct the object rotation matrix.  A waste to do this per vertex, but GPU >> CPU, especially javascript...\n  vec3 X = normalize(objectAxis);\n  vec3 Z = cross(X,normalize(objectUp));\n  if ( dot(Z,Z) < 1e-10 ) {\n    Z = cross(X, vec3(1,0,0));\n    if (dot(Z,Z) < 1e-10 )\n        Z = cross(X, vec3(0,1,0));\n  }\n  Z = normalize(Z);\n  return mat3( X, normalize(cross(Z,X)), Z );\n}\n\nvoid main(void) {\n  mat3 rot = getObjectRotation();\n\n  es_normal = (viewMatrix * vec4(rot*normal, 0.0)).xyz;\n  vec4 pos4 = viewMatrix * vec4( rot*(objectScale*position) + objectPos, 1.0);\n  es_position = pos4.xyz;\n  gl_Position = projMatrix * pos4;\n  mat_pos = position;\n  mat_color = objectColor;\n}",
"plastic_fragment":'#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec3 es_position;        // eye space surface position\nvarying vec3 es_normal;          // eye space surface normal\nvarying vec3 mat_pos;         // surface material position in [0,1]^3\nvarying vec4 mat_color;\n\nuniform int light_count;\nuniform vec4 light_pos[8];\nuniform vec3 light_color[8];\nuniform float shininess;\n\n#define AMBIENT 0.2\n// Return lit surface color based on the given surface properties and the lights\n//   specified by the light_* uniforms.\nvec3 lightAt( vec3 normal, vec3 pos, vec3 diffuse_color, vec3 specular_color, float shininess )\n{    \n    vec3 color = AMBIENT * diffuse_color;\n\n    for(int i=0; i<8; i++) {\n        if (i >= light_count) break;\n        vec3 L = normalize( light_pos[i].xyz - pos*light_pos[i].w );\n        color += (light_color[i].rgb * max(dot(normal,L), 0.0))*diffuse_color;\n        if (shininess != 0.0) {\n            vec3 R = reflect(L,normal);\n            color += specular_color * light_color[i].rgb * pow(max(dot(R,normalize(pos)),0.0),shininess);\n        }\n    }\n            \n    return color;\n}\n\nvoid main(void) {\n  vec3 color = lightAt(normalize(es_normal),es_position,mat_color.rgb,vec3(.8,.8,.8),shininess);\n  gl_FragColor = vec4( color, 1.0 );\n}\n\n',
};